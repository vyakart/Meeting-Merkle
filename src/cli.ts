#!/usr/bin/env node
import { promises as fs } from 'fs';
import process from 'process';
import { loadMeetingRecord, parseMeetingRecord, ValidationError } from './io';
import {
  buildMerkleTree,
  computeLeafHash,
  computeRootForMeeting,
  generateMembershipProof,
  MerkleProofNode,
  verifyMeeting,
  verifyProof,
} from './merkle';

interface ProofFile {
  meeting_id: string;
  timestamp: string;
  salt?: string;
  index: number;
  item: { agenda: string; notes: string };
  leaf: string;
  proof: MerkleProofNode[];
  root: string;
}

function printUsage(): void {
  console.log(`meeting-merkle <command> [arguments]\n\nCommands:\n  root <meeting.json>            Compute the Merkle root for a meeting record\n  verify <meeting.json> <root>   Verify a meeting record against an expected root\n  proof <meeting.json> <index> [--pretty]\n                                Generate a membership proof for the item at index\n  proof-verify <proof.json>      Verify a membership proof generated by this tool`);
}

function exitWithError(message: string, code = 1): never {
  console.error(`Error: ${message}`);
  process.exit(code);
}

async function handleRoot(filePath: string | undefined) {
  if (!filePath) {
    exitWithError('Missing meeting JSON path for root command');
  }
  const meeting = await loadMeetingRecord(filePath);
  const tree = buildMerkleTree(meeting.items, meeting.salt);
  console.log(tree.root);
}

async function handleVerify(filePath: string | undefined, root: string | undefined) {
  if (!filePath || !root) {
    exitWithError('verify requires <meeting.json> and <root> arguments');
  }
  const meeting = await loadMeetingRecord(filePath);
  if (verifyMeeting(meeting, root)) {
    console.log('OK: meeting record matches the supplied Merkle root');
    return;
  }
  console.error('FAIL: meeting record does not match the supplied Merkle root');
  process.exit(1);
}

async function handleProof(args: string[]) {
  const pretty = args.includes('--pretty');
  const filtered = args.filter((arg) => arg !== '--pretty');
  const [filePath, indexArg] = filtered;
  if (!filePath || indexArg === undefined) {
    exitWithError('proof requires <meeting.json> and <index> arguments');
  }
  const index = Number.parseInt(indexArg, 10);
  if (!Number.isInteger(index) || index < 0) {
    exitWithError('index must be a non-negative integer');
  }

  const meeting = await loadMeetingRecord(filePath);
  if (index >= meeting.items.length) {
    exitWithError(`index ${index} is out of bounds for items array of length ${meeting.items.length}`);
  }

  const proof = generateMembershipProof(meeting.items, index, meeting.salt);
  const document: ProofFile = {
    meeting_id: meeting.meeting_id,
    timestamp: meeting.timestamp,
    salt: meeting.salt,
    index,
    item: meeting.items[index],
    leaf: proof.leaf,
    proof: proof.proof,
    root: proof.root,
  };

  const output = pretty ? JSON.stringify(document, null, 2) : JSON.stringify(document);
  console.log(output);
}

async function loadProofFile(filePath: string): Promise<ProofFile> {
  const raw = await fs.readFile(filePath, 'utf8');
  let parsed: unknown;
  try {
    parsed = JSON.parse(raw);
  } catch (error) {
    exitWithError(`Failed to parse proof JSON: ${(error as Error).message}`);
  }

  if (parsed === null || typeof parsed !== 'object' || Array.isArray(parsed)) {
    exitWithError('Proof document must be a JSON object');
  }
  const value = parsed as Partial<ProofFile>;

  const requiredString = (field: keyof ProofFile) => {
    const current = value[field];
    if (typeof current !== 'string') {
      exitWithError(`Proof document is missing string field ${String(field)}`);
    }
    return current;
  };

  const meeting_id = requiredString('meeting_id');
  const timestamp = requiredString('timestamp');
  const root = requiredString('root');
  const leaf = requiredString('leaf');

  const indexValue = value.index;
  if (typeof indexValue !== 'number' || !Number.isInteger(indexValue) || indexValue < 0) {
    exitWithError('Proof document index must be a non-negative integer');
  }

  const itemValue = (value as { item?: unknown }).item;
  if (itemValue === null || typeof itemValue !== 'object' || Array.isArray(itemValue)) {
    exitWithError('Proof document item must be an object with agenda and notes');
  }
  const { agenda, notes } = itemValue as { agenda?: unknown; notes?: unknown };
  if (typeof agenda !== 'string' || typeof notes !== 'string') {
    exitWithError('Proof document item.agenda and item.notes must be strings');
  }

  const saltValue = value.salt;
  if (saltValue !== undefined && typeof saltValue !== 'string') {
    exitWithError('Proof document salt must be a string when provided');
  }

  const proofArray = value.proof;
  if (!Array.isArray(proofArray)) {
    exitWithError('Proof document proof must be an array');
  }
  const proof: MerkleProofNode[] = proofArray.map((entry, i) => {
    if (entry === null || typeof entry !== 'object' || Array.isArray(entry)) {
      exitWithError(`Proof step at index ${i} must be an object`);
    }
    const { position, hash } = entry as { position?: unknown; hash?: unknown };
    if (position !== 'left' && position !== 'right') {
      exitWithError(`Proof step at index ${i} must have position "left" or "right"`);
    }
    if (typeof hash !== 'string') {
      exitWithError(`Proof step at index ${i} must include a hash string`);
    }
    return { position, hash } as MerkleProofNode;
  });

  return {
    meeting_id,
    timestamp,
    salt: saltValue,
    index: indexValue,
    item: { agenda, notes },
    leaf,
    proof,
    root,
  };
}

async function handleProofVerify(filePath: string | undefined) {
  if (!filePath) {
    exitWithError('proof-verify requires <proof.json> argument');
  }
  const proofDoc = await loadProofFile(filePath);

  let canonicalItemRecord;
  try {
    canonicalItemRecord = parseMeetingRecord({
      meeting_id: proofDoc.meeting_id,
      timestamp: proofDoc.timestamp,
      salt: proofDoc.salt,
      items: [proofDoc.item],
    });
  } catch (error) {
    if (error instanceof ValidationError) {
      exitWithError(`Proof document content is invalid: ${error.message}`);
    }
    throw error;
  }

  const canonicalItem = canonicalItemRecord.items[0];
  const leaf = computeLeafHash(canonicalItem, canonicalItemRecord.salt);
  const expectedLeaf = proofDoc.leaf.toLowerCase();
  if (leaf !== expectedLeaf) {
    exitWithError('Proof leaf does not match the canonicalized item payload');
  }

  let proofValid = false;
  try {
    proofValid = verifyProof(leaf, proofDoc.proof, proofDoc.root);
  } catch (error) {
    if (error instanceof Error) {
      exitWithError(`Failed to verify proof: ${error.message}`);
    }
    throw error;
  }

  if (!proofValid) {
    exitWithError('Proof is invalid for the supplied root');
  }

  console.log('OK: membership proof is valid for the supplied Merkle root');
}

async function main() {
  const [command, ...rest] = process.argv.slice(2);
  try {
    switch (command) {
      case 'root':
        await handleRoot(rest[0]);
        break;
      case 'verify':
        await handleVerify(rest[0], rest[1]);
        break;
      case 'proof':
        await handleProof(rest);
        break;
      case 'proof-verify':
        await handleProofVerify(rest[0]);
        break;
      case undefined:
        printUsage();
        process.exit(1);
        break;
      default:
        console.error(`Unknown command: ${command}`);
        printUsage();
        process.exit(1);
    }
  } catch (error) {
    if (error instanceof ValidationError) {
      exitWithError(error.message);
    }
    throw error;
  }
}

if (require.main === module) {
  main().catch((error) => {
    console.error(error instanceof Error ? error.message : error);
    process.exit(1);
  });
}
