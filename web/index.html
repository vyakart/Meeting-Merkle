<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Merkle-Meet — Tamper-evident, privacy-preserving minutes</title>
<link rel="icon" href="data:,">
<style>
:root{
  color-scheme: dark;
  --bg: #0b0f14;
  --panel: #0d131a;
  --ink: #e7f8ff;
  --muted: #9fb0bf;
  --accent: #00ffd1;
  --accent-2: #ff00a8;
  --danger: #ff4d6d;
  --ok: #3dfc9a;
  --mono: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace;

  --br: 10px;
  --glow: 0 0 6px rgba(0,255,209,.35), 0 0 24px rgba(255,0,168,.18);
  --line: 1px solid rgba(255,255,255,.06);
  --border-weak: rgba(255,255,255,.12);
  --border-strong: rgba(255,255,255,.24);
  --feed-border: rgba(0,255,209,.18);
  --feed-bg: rgba(9,16,23,.92);
  --feed-text: #c8ffef;
  --input-bg: #0a0f14;
  --button-bg: #0b1218;
  --body-gradient: radial-gradient(1200px 600px at 80% 0%, rgba(255,0,168,.07), transparent 40%),
                   radial-gradient(1000px 700px at 0% 100%, rgba(0,255,209,.07), transparent 40%),
                   var(--bg);
  --page-max-width: 1200px;
  --page-padding: clamp(12px, 3vw, 28px);
  --header-height: 64px;
}

[data-theme="light"]{
  color-scheme: light;
  --bg: #f6f8fb;
  --panel: #ffffff;
  --ink: #0b111a;
  --muted: #4c6072;
  --accent: #0066ff;
  --accent-2: #ff3fb4;
  --danger: #d42a4a;
  --ok: #158a4c;
  --glow: 0 0 6px rgba(0,102,255,.25), 0 0 24px rgba(255,63,180,.15);
  --line: 1px solid rgba(8,16,24,.08);
  --border-weak: rgba(11,17,26,.14);
  --border-strong: rgba(11,17,26,.28);
  --feed-border: rgba(0,102,255,.18);
  --feed-bg: rgba(237,242,250,.92);
  --feed-text: #17324a;
  --input-bg: #eef2f8;
  --button-bg: #f5f7fb;
  --body-gradient: radial-gradient(1200px 600px at 80% 0%, rgba(0,102,255,.08), transparent 40%),
                   radial-gradient(1000px 700px at 0% 100%, rgba(255,63,180,.08), transparent 40%),
                   var(--bg);
}
*{box-sizing:border-box}
html,body{height:100%}
body{
  margin:0; background: var(--body-gradient);
  color:var(--ink); font-family: var(--mono); letter-spacing:.2px;
  min-height:100vh; display:flex; flex-direction:column;
}
.header{
  padding:12px var(--page-padding); border-bottom: var(--line);
  display:flex; align-items:center; gap:12px; min-height:var(--header-height, 64px);
  background: linear-gradient(180deg, rgba(255,255,255,.03), rgba(255,255,255,0));
}
.brand{
  font-weight:700; font-size:18px; letter-spacing:.6px;
}
.tagline{color:var(--muted); font-size:12px}

.badge{
  margin-left:8px; padding:4px 10px; border:1px solid var(--border-weak);
  border-radius:999px; color:var(--muted); display:flex; align-items:center; gap:8px;
}
.grid{
  display:grid;
  grid-template-columns: minmax(260px, 320px) minmax(0, 1fr);
  gap:clamp(12px, 2.5vw, 20px);
  padding:var(--page-padding);
  width:min(100%, var(--page-max-width));
  margin:0 auto;
  min-height:calc(100vh - var(--header-height, 64px));
  align-items:start;
  flex:1 1 auto;
}
.sidebar{
  background: var(--panel); border: var(--line); border-radius: var(--br); padding:12px; overflow:auto;
}
.step{
  border-radius:8px;
  border:1px dashed rgba(255,255,255,.08);
  margin-bottom:10px;
  background:rgba(255,255,255,.02);
}
.step summary{
  cursor:pointer;
  list-style:none;
  padding:8px 10px;
  font-size:13px;
  color:var(--accent);
  font-weight:600;
  display:flex;
  align-items:center;
  justify-content:space-between;
  gap:12px;
}
.step summary::-webkit-details-marker{display:none;}
.step .step-body{padding:0 10px 10px 10px;}
.step .step-body p{margin:0 0 8px 0; color:var(--muted); font-size:12px; line-height:1.4}
.step .actions{display:flex; flex-wrap:wrap; gap:6px}
.step-help{
  border:none;
  background:rgba(255,255,255,.08);
  color:var(--muted);
  border-radius:50%;
  width:20px;
  height:20px;
  font-size:12px;
  display:inline-flex;
  align-items:center;
  justify-content:center;
  cursor:pointer;
}
.step-help:focus-visible{outline:2px solid var(--accent);}
.step-helptext{
  display:none;
  font-size:12px;
  color:var(--muted);
  border-left:2px solid rgba(255,255,255,.08);
  padding-left:8px;
  margin-bottom:8px;
}
.step-helptext.visible{display:block;}
button,.btn{
  background:var(--button-bg); color:var(--ink); border:1px solid var(--border-weak);
  padding:8px 10px; border-radius:8px; cursor:pointer; font-family:var(--mono);
}
button:not(.cta-button):hover{border-color:var(--border-strong)}
button.primary{
  border-color: var(--accent); box-shadow: var(--glow);
}
button.ghost{background:transparent}
.icon-button{
  display:inline-flex;
  align-items:center;
  justify-content:center;
  padding:8px;
  gap:0;
}
a.icon-button{
  border:1px solid var(--border-weak);
  border-radius:8px;
  background:var(--button-bg);
  color:var(--ink);
  text-decoration:none;
  cursor:pointer;
}
a.icon-button:hover{border-color:var(--border-strong);}
a.icon-button:focus-visible{
  outline:2px solid var(--accent);
  outline-offset:2px;
}
.icon-button svg{
  width:16px;
  height:16px;
  display:block;
  stroke:currentColor;
  stroke-width:1.6;
  stroke-linecap:round;
  stroke-linejoin:round;
  fill:none;
}

.cta-button{
  position:relative;
  display:inline-flex;
  flex-direction:column;
  align-items:flex-start;
  gap:2px;
  padding:12px 16px;
  border-radius:14px;
  background:linear-gradient(135deg, rgba(0,255,209,.18), rgba(255,0,168,.16));
  border:1px solid rgba(255,255,255,.18);
  color:var(--ink);
  box-shadow:0 14px 28px rgba(0,0,0,.22);
  transition:transform .15s ease, box-shadow .15s ease, border-color .15s ease;
}
.cta-button:hover{
  transform:translateY(-1px);
  border-color:rgba(0,255,209,.4);
  box-shadow:0 18px 32px rgba(0,0,0,.28);
}
.cta-button:focus-visible{
  outline:2px solid var(--accent);
  outline-offset:2px;
}
.cta-label{font-size:13px; font-weight:700; letter-spacing:.3px;}
.cta-sub{font-size:11px; color:var(--muted);}
#theme-toggle{
  margin-left:auto;
  width:40px;
  height:40px;
  display:flex;
  align-items:center;
  justify-content:center;
  border-radius:12px;
  padding:0;
}
#theme-toggle svg{width:20px;height:20px;display:block;stroke:currentColor;stroke-width:1.5;}
#theme-toggle circle{stroke:currentColor;fill:none;}
#theme-toggle line{stroke:currentColor;stroke-linecap:round;}
#theme-toggle path{stroke:currentColor;stroke-linecap:round;fill:currentColor;stroke-width:1.2;}
input,textarea{
  width:100%; background:var(--input-bg); color:var(--ink); border:1px solid var(--border-weak);
  border-radius:8px; padding:10px; font-family:var(--mono); font-size:12px;
}
label{font-size:12px; color:var(--muted)}
.main{
  display:grid; grid-template-rows: auto 1fr auto; gap:12px; min-height:0;
}
.panel{
  background: var(--panel); border: var(--line); border-radius: var(--br); padding:12px; min-height:0;
}
.hero{
  display:flex; align-items:flex-start; justify-content:space-between; gap:12px;
  position:sticky;
  top:-1px;
  z-index:10;
  background:var(--panel);
  border-bottom:1px solid rgba(255,255,255,.04);
  padding-bottom:12px;
}
.hero .left{display:flex; flex-direction:column; gap:4px}
.hero .title{font-size:16px; font-weight:700}
.hero .subtitle{font-size:12px; color:var(--muted)}
.hero .actions{display:flex; flex-wrap:wrap; gap:8px; align-items:center;}
.kv{
  display:grid; grid-template-columns: 1fr 1fr; gap:12px;
}
.kv .box{display:flex; flex-direction:column; gap:6px}
.feed{
  background:var(--feed-bg); border:1px solid var(--feed-border); border-radius:8px;
  padding:10px; font-size:12px; color:var(--feed-text);
  max-height:clamp(180px, 32vh, 300px);
  overflow:auto;
}
.feed .line{white-space:pre-wrap; margin:0 0 4px 0}
.feed .ok{color:var(--ok)}
.feed .bad{color:var(--danger)}
.mono{font-family:var(--mono)}
.row{display:flex; gap:8px; align-items:center}
.small{font-size:12px}
.code{background:#081018; border:1px solid rgba(255,255,255,.12); border-radius:8px; padding:8px; font-size:12px}
.status{
  display:flex;
  align-items:flex-start;
  gap:10px;
  color:var(--muted);
  font-size:12px;
}
.root-readout{margin:0; display:flex; align-items:center; gap:6px; font-size:12px; color:var(--muted); font-family:var(--mono);}
.dot{width:8px;height:8px;border-radius:50%;background:#8b93a0;border:1px solid #444}
.dot.ok{background:var(--ok); box-shadow:0 0 10px rgba(61,252,154,.6)}
.dot.bad{background:var(--danger); box-shadow:0 0 10px rgba(255,77,109,.6)}
.status-info{display:flex; flex-direction:column; gap:4px;}
.status-message{color:var(--muted); font-family:var(--mono); font-size:11px; letter-spacing:.3px;}
.status-message.ok{color:var(--ok);}
.status-message.error{color:var(--danger);}
.status-message:empty{display:none;}
.footer{
  display:flex; justify-content:space-between; align-items:center; gap:8px; color:var(--muted); font-size:12px
}
a.link{color:var(--accent)}
hr.div{border:0;border-top:1px solid rgba(255,255,255,.08);margin:8px 0}
.scanlines{
  position:fixed; inset:0; pointer-events:none;
  background: repeating-linear-gradient(0deg, rgba(255,255,255,.02), rgba(255,255,255,.02) 1px, transparent 1px, transparent 3px);
  mix-blend-mode:overlay; opacity:.25;
}
body.modal-open{overflow:hidden;}

.transcript-overlay{
  position:fixed;
  inset:0;
  background:rgba(6,12,18,0.78);
  backdrop-filter:blur(10px);
  display:none;
  align-items:center;
  justify-content:center;
  padding:clamp(16px, 5vw, 24px);
  z-index:1000;
}

.transcript-overlay.open{display:flex;}

.transcript-dialog{
  width:min(960px,100%);
  max-height:90vh;
  overflow:auto;
  background:var(--panel);
  border:var(--line);
  border-radius:var(--br);
  padding:20px;
  box-shadow:0 40px 80px rgba(0,0,0,0.45);
  display:flex;
  flex-direction:column;
  gap:16px;
}

.transcript-dialog header{
  display:flex;
  align-items:center;
  justify-content:space-between;
  gap:12px;
}

.transcript-dialog h2{
  margin:0;
  font-size:16px;
  letter-spacing:.4px;
}

.transcript-grid{
  display:grid;
  grid-template-columns:repeat(2,minmax(0,1fr));
  gap:16px;
}

@media (max-width: 960px){
  .transcript-grid{grid-template-columns:1fr;}
}

.transcript-section{
  display:flex;
  flex-direction:column;
  gap:8px;
}

.transcript-actions{
  display:flex;
  flex-wrap:wrap;
  gap:8px;
}

.transcript-note{
  font-size:12px;
  color:var(--muted);
}

.example-overlay{
  position:fixed;
  inset:0;
  background:rgba(6,12,18,0.78);
  backdrop-filter:blur(10px);
  display:none;
  align-items:center;
  justify-content:center;
  padding:clamp(16px, 5vw, 24px);
  z-index:900;
}

.example-overlay.open{display:flex;}

.example-dialog{
  width:min(880px,100%);
  max-height:88vh;
  overflow:auto;
  background:var(--panel);
  border:var(--line);
  border-radius:var(--br);
  padding:20px;
  box-shadow:0 32px 64px rgba(0,0,0,0.45);
  display:flex;
  flex-direction:column;
  gap:16px;
}

.example-dialog header{display:flex;align-items:center;justify-content:space-between;gap:12px;}
.example-dialog h2{margin:0;font-size:16px;letter-spacing:.4px;}
.example-intro{margin:0;color:var(--muted);font-size:12px;line-height:1.5;}
.example-grid{display:grid;grid-template-columns:repeat(2,minmax(0,1fr));gap:12px;}
.example-card{border:1px solid rgba(255,255,255,.08);border-radius:12px;padding:14px;background:rgba(255,255,255,.03);display:flex;flex-direction:column;gap:10px;}
.example-card h3{margin:0;font-size:14px;}
.example-card p{margin:0;color:var(--muted);font-size:12px;line-height:1.5;}
.example-card footer{display:flex;gap:8px;flex-wrap:wrap;margin-top:auto;}
.example-card button{flex:1 1 auto;}

@media (max-width: 720px){
  .header{
    flex-wrap:wrap;
    align-items:flex-start;
    gap:8px 16px;
  }
  #theme-toggle{
    margin-left:0;
    order:3;
  }
  .tagline{
    flex:1 1 100%;
  }
  .badge{margin-left:0;}
  .hero{
    position:static;
    flex-direction:column;
    gap:16px;
  }
  .hero .actions{
    width:100%;
    justify-content:flex-start;
  }
  .hero .actions > *{
    flex:1 1 140px;
  }
  .feed{max-height:50vh;}
  .example-grid{grid-template-columns:1fr;}
}

@media (max-width: 520px){
  .hero .actions{
    flex-direction:column;
    align-items:stretch;
  }
  .cta-button{width:100%;}
  .badge{width:100%; justify-content:space-between;}
  .footer{flex-direction:column; align-items:flex-start; gap:12px;}
}

.salt-row{display:flex; align-items:center; gap:6px; flex-wrap:wrap;}
.salt-tip{font-size:12px; color:var(--muted); display:flex; align-items:center; gap:6px;}
.salt-tip button{padding:4px 10px; font-size:11px; border-radius:999px;}
.tooltip{position:relative; display:inline-flex; align-items:center;}
.tooltip:hover .tooltip-content,
.tooltip:focus-within .tooltip-content{opacity:1; transform:translateY(0); pointer-events:auto;}
.tooltip-icon{
  width:16px;
  height:16px;
  border-radius:50%;
  background:rgba(255,255,255,.08);
  display:inline-flex;
  align-items:center;
  justify-content:center;
  font-size:11px;
  cursor:pointer;
}
.tooltip-content{
  position:absolute;
  bottom:calc(100% + 6px);
  left:50%;
  transform:translate(-50%, 6px);
  background:var(--panel);
  border:1px solid var(--border-weak);
  border-radius:8px;
  padding:8px 10px;
  font-size:11px;
  color:var(--muted);
  width:220px;
  box-shadow:0 12px 32px rgba(0,0,0,.25);
  opacity:0;
  pointer-events:none;
  transition:opacity .15s ease, transform .15s ease;
  z-index:20;
}
.tooltip-content p{margin:0;}
.tooltip-content a{display:inline-block;margin-top:6px;}

.items-overview{
  border:1px solid var(--border-weak);
  border-radius:10px;
  padding:8px;
  max-height:240px;
  overflow:auto;
  background:rgba(255,255,255,.02);
}
.items-overview label{
  display:grid;
  grid-template-columns:16px 1fr;
  gap:10px;
  align-items:flex-start;
  font-size:12px;
  color:var(--ink);
  padding:8px 6px;
  border-radius:8px;
  cursor:pointer;
  line-height:1.45;
}
.items-overview label:hover{background:rgba(255,255,255,.04);}
.items-overview input[type="radio"]{margin-top:3px;}
.items-overview .item-body{display:flex; flex-direction:column; gap:2px;}
.items-overview .item-title{font-weight:600; display:block;}
.items-overview .item-notes{color:var(--muted); font-size:11px; display:block; line-height:1.4;}

.proof-row{
  margin-top:6px;
  display:flex;
  gap:8px;
  align-items:center;
  flex-wrap:wrap;
}
.proof-row input{
  flex:1 1 220px;
  min-width:180px;
  width:auto;
}
.proof-actions{
  display:inline-flex;
  align-items:center;
  margin:0;
  border:1px solid var(--border-weak);
  border-radius:10px;
  overflow:hidden;
  background:var(--button-bg);
}
.proof-actions button{
  border:0;
  background:transparent;
  color:var(--ink);
  font-family:var(--mono);
  font-size:12px;
  padding:8px 14px;
  border-radius:0;
  display:inline-flex;
  align-items:center;
  justify-content:center;
  gap:6px;
  white-space:nowrap;
}
.proof-actions button + button{border-left:1px solid var(--border-weak);}
.proof-actions .icon-button{padding:8px; width:38px;}
.proof-actions button:hover{background:rgba(255,255,255,.05);}
.proof-actions button:focus-visible{outline:2px solid var(--accent); outline-offset:-2px;}
.feed ul{margin:0;padding-left:18px;}

.hero-sticky-spacer{height:0;}
body.modal-open{overflow:hidden;}

.transcript-overlay{
  position:fixed;
  inset:0;
  background:rgba(6,12,18,0.78);
  backdrop-filter:blur(10px);
  display:none;
  align-items:center;
  justify-content:center;
  padding:clamp(16px, 5vw, 24px);
  z-index:1000;
}

.transcript-overlay.open{display:flex;}

.transcript-dialog{
  width:min(960px,100%);
  max-height:90vh;
  overflow:auto;
  background:var(--panel);
  border:var(--line);
  border-radius:var(--br);
  padding:20px;
  box-shadow:0 40px 80px rgba(0,0,0,0.45);
  display:flex;
  flex-direction:column;
  gap:16px;
}

.transcript-dialog header{
  display:flex;
  align-items:center;
  justify-content:space-between;
  gap:12px;
}

.transcript-note{
  font-size:12px;
  color:var(--muted);
}
@media (max-width: 900px){
  .grid{
    grid-template-columns:1fr;
    min-height:auto;
    padding:clamp(12px, 4vw, 20px);
  }
  .sidebar{order:2;}
  .main{order:1;}
  .kv{grid-template-columns:1fr}
  .hero{top:0;}
  .step{border:1px solid rgba(255,255,255,.12);}
}
</style>
</head>
<body>
  <div class="header" role="banner">
    <div class="brand">MERKLE-MEET</div>
    <div class="tagline">Tamper-evident, privacy-preserving minutes</div>
    <button class="ghost" id="theme-toggle" type="button" aria-label="Toggle theme">Light Theme</button>
    <a class="icon-button" href="https://github.com/vyakart/Meeting-Merkle" target="_blank" rel="noopener noreferrer" aria-label="Open Meeting-Merkle on GitHub" title="GitHub repository">
      <svg viewBox="0 0 24 24" aria-hidden="true" focusable="false" style="fill:currentColor;stroke:none;">
        <path d="M12 2C6.48 2 2 6.58 2 12.2c0 4.49 2.87 8.3 6.84 9.65.5.1.68-.22.68-.48 0-.24-.01-.87-.01-1.71-2.78.62-3.37-1.36-3.37-1.36-.45-1.15-1.11-1.45-1.11-1.45-.91-.64.07-.63.07-.63 1 .07 1.53 1.05 1.53 1.05.89 1.57 2.32 1.12 2.89.86.09-.66.35-1.12.63-1.37-2.22-.26-4.55-1.14-4.55-5.07 0-1.12.39-2.03 1.03-2.75-.1-.26-.45-1.3.1-2.7 0 0 .84-.28 2.75 1.05a9.25 9.25 0 0 1 5 0c1.9-1.33 2.74-1.05 2.74-1.05.55 1.4.2 2.44.1 2.7.64.72 1.03 1.63 1.03 2.75 0 3.94-2.33 4.81-4.56 5.07.36.32.68.94.68 1.89 0 1.36-.01 2.46-.01 2.79 0 .26.18.59.69.48A10.22 10.22 0 0 0 22 12.2C22 6.58 17.52 2 12 2Z"></path>
      </svg>
    </a>
    <div class="badge" aria-live="polite">
      <span class="dot" id="integrity-dot" title="Integrity badge"></span> integrity
    </div>
  </div>

  <div class="grid" role="main">
    <aside class="sidebar" aria-label="Steps">
      <details class="step" id="step-0-transcript" open>
        <summary>
          <span>Step 0 — From Transcript (optional)</span>
          <button class="step-help" type="button" data-help="help-step-0" aria-label="Explain transcript conversion">?</button>
        </summary>
        <div class="step-body">
          <div class="step-helptext" id="help-step-0">Use a raw transcript to auto-build meeting minutes before hashing. The parser extracts agenda lines and notes into structured JSON.</div>
          <p>Drop in a raw transcript, convert to meeting JSON, then copy, download, or fill Step 1 automatically.</p>
          <div class="actions">
            <button class="ghost" id="btn-transcript-panel" type="button">Open Transcript Converter</button>
          </div>
        </div>
      </details>

      <details class="step" id="step-1" open>
        <summary>
          <span>Step 1 — Load Minutes</span>
          <button class="step-help" type="button" data-help="help-step-1" aria-label="Explain minutes JSON">?</button>
        </summary>
        <div class="step-body">
          <div class="step-helptext" id="help-step-1">Minutes JSON is the canonical record we hash. Each agenda item becomes a Merkle leaf in the order it appears. Review or edit it before computing the root.</div>
          <p>Paste your minutes JSON. You can load an example to explore.</p>
          <div class="actions">
            <button class="ghost" id="btn-example">Load JSON</button>
            <button class="ghost" id="btn-clear">Clear</button>
          </div>
        </div>
      </details>

      <details class="step" id="step-2" open>
        <summary>
          <span>Step 2 — Compute Root</span>
          <button class="step-help" type="button" data-help="help-step-2" aria-label="Explain Merkle root">?</button>
        </summary>
        <div class="step-body">
          <div class="step-helptext" id="help-step-2">A Merkle root is a single fingerprint for the entire meeting. Any change to agenda or notes alters the root, making tampering evident.</div>
          <p>Normalize → hash items (SHA-256) → build Merkle tree.</p>
          <div class="actions">
            <button class="primary" id="btn-root">Compute Root</button>
            <button class="icon-button" id="btn-copy-root" type="button" aria-label="Copy root">
              <svg viewBox="0 0 24 24" aria-hidden="true" focusable="false">
                <rect x="9" y="3" width="11" height="14" rx="2"></rect>
                <rect x="4" y="7" width="11" height="14" rx="2"></rect>
              </svg>
            </button>
          </div>
        </div>
      </details>

      <details class="step" id="step-3" open>
        <summary>
          <span>Step 3 — Publish &amp; Share</span>
          <button class="step-help" type="button" data-help="help-step-3" aria-label="Explain publishing the root">?</button>
        </summary>
        <div class="step-body">
          <div class="step-helptext" id="help-step-3">Share the Merkle root (and proof, if needed) with your team. Anyone can recompute the root locally and confirm it matches.</div>
          <p>Post the root where others can see (e.g. Slack).</p>
          <div class="actions">
            <button id="btn-slack">Compose Slack message</button>
            <button class="icon-button" id="btn-slack-copy" type="button" aria-label="Copy Slack message">
              <svg viewBox="0 0 24 24" aria-hidden="true" focusable="false">
                <rect x="9" y="3" width="11" height="14" rx="2"></rect>
                <rect x="4" y="7" width="11" height="14" rx="2"></rect>
              </svg>
            </button>
          </div>
        </div>
      </details>

      <details class="step" id="step-4" open>
        <summary>
          <span>Step 4 — Verify Record</span>
          <button class="step-help" type="button" data-help="help-step-4" aria-label="Explain verification">?</button>
        </summary>
        <div class="step-body">
          <div class="step-helptext" id="help-step-4">Verification recomputes the fingerprint from your minutes and checks it against an expected root. Matching roots confirm no changes were made.</div>
          <p>Recompute from JSON and compare to an expected root.</p>
          <div class="actions row">
            <input id="expected-root" placeholder="Expected root (hex)" aria-label="Expected root" />
            <button id="btn-verify-root">Verify Against Root</button>
          </div>
        </div>
      </details>

      <details class="step" id="step-5" open>
        <summary>
          <span>Step 5 — Generate Proof</span>
          <button class="step-help" type="button" data-help="help-step-5" aria-label="Explain membership proofs">?</button>
        </summary>
        <div class="step-body">
          <div class="step-helptext" id="help-step-5">A membership proof lets you show one agenda item was part of the meeting without revealing the rest of the notes.</div>
          <p>Select an agenda item (radio list beside the minutes) to generate its inclusion proof.</p>
          <div class="actions row proof-row">
            <input id="proof-index" placeholder="Item index (0-based)" aria-label="Item index (optional)" />
            <button class="primary" id="btn-proof" type="button">Create Proof</button>
            <div class="proof-actions">
              <button class="icon-button" id="btn-proof-copy" type="button" aria-label="Copy proof JSON">
                <svg viewBox="0 0 24 24" aria-hidden="true" focusable="false">
                  <rect x="9" y="3" width="11" height="14" rx="2"></rect>
                  <rect x="4" y="7" width="11" height="14" rx="2"></rect>
                </svg>
              </button>
              <button class="icon-button" id="btn-proof-download" type="button" aria-label="Download proof JSON">
                <svg viewBox="0 0 24 24" aria-hidden="true" focusable="false">
                  <path d="M12 4v10"></path>
                  <path d="M8 10l4 4 4-4"></path>
                  <rect x="5" y="18" width="14" height="2" rx="1"></rect>
                </svg>
              </button>
            </div>
          </div>
        </div>
      </details>

      <details class="step" id="step-6" open>
        <summary>
          <span>Step 6 — Verify Proof</span>
          <button class="step-help" type="button" data-help="help-step-6" aria-label="Explain proof verification">?</button>
        </summary>
        <div class="step-body">
          <div class="step-helptext" id="help-step-6">Proof verification replays the Merkle path to ensure the proof matches the root you trust. If any hash or ordering is wrong, verification fails.</div>
          <p>Check a membership proof against the root.</p>
          <div class="actions">
            <button id="btn-verify-proof">Verify Proof</button>
            <button class="icon-button" id="btn-copy-output" type="button" aria-label="Copy output">
              <svg viewBox="0 0 24 24" aria-hidden="true" focusable="false">
                <rect x="9" y="3" width="11" height="14" rx="2"></rect>
                <rect x="4" y="7" width="11" height="14" rx="2"></rect>
              </svg>
            </button>
          </div>
        </div>
      </details>
    </aside>

    <section class="main">
      <div class="panel hero" aria-live="polite">
        <div class="left">
          <div class="title">Trust the minutes. Not the note-taker.</div>
          <div class="subtitle">All verification is local. No servers. No secrets leaked.</div>
          <div class="actions">
            <button class="cta-button" id="btn-try-it" type="button">
              <span class="cta-label">Walk through an example</span>
              <span class="cta-sub">Load curated minutes &rarr;</span>
            </button>
          </div>
        </div>
        <div class="status">
          <span class="dot" id="integrity-dot" aria-label="Integrity status: idle"></span>
          <div class="status-info">
            <div class="root-readout"><span>Root:</span> <code id="root" class="mono">—</code></div>
            <div class="status-message" id="integrity-label" aria-live="polite"></div>
          </div>
        </div>
      </div>

      <div class="panel kv">
        <div class="box">
          <label for="json">Minutes JSON</label>
          <textarea id="json" rows="12" placeholder='Paste your minutes JSON here...'></textarea>
          <div class="salt-row small">
            <div class="row small" style="gap:6px;align-items:center;">
              <label for="salt" style="min-width:80px;margin:0;">Salt (opt.)</label>
              <div class="tooltip">
                <button type="button" class="tooltip-icon" aria-describedby="salt-tooltip">i</button>
                <div class="tooltip-content" role="tooltip" id="salt-tooltip">
                  <p>Salts add randomness so identical minutes produce different hashes.</p>
                  <a href="#" class="why-link">Learn more</a>
                </div>
              </div>
            </div>
            <input id="salt" placeholder="random-16-bytes" aria-label="Salt" />
            <button id="btn-salt-generate" type="button">Generate random salt</button>
          </div>
          <div class="items-overview" id="items-overview" role="radiogroup" aria-live="polite" aria-label="Agenda items"></div>
        </div>

        <div class="box">
          <label>Terminal Feed</label>
          <div class="feed" id="feed" aria-live="polite" aria-atomic="false">
            <ul class="small" id="empty-line">
              <li>1. Load or convert minutes JSON.</li>
              <li>2. Compute the Merkle root (salt optional).</li>
              <li>3. Share or verify proofs as needed.</li>
            </ul>
          </div>
          <hr class="div" />
          <div class="box">
            <label for="output">Output</label>
            <textarea id="output" rows="6" class="mono" placeholder="Proofs, verification results, and composer text appear here."></textarea>
          </div>
        </div>
      </div>

      <div class="panel footer">
        <div>SHA-256 • Odd-leaf duplication • Canonical JSON • Local-only</div>
        <div><a class="link why-link" href="#" id="why-link">Why salting matters</a></div>
      </div>
    </section>
  </div>

  <div class="scanlines" aria-hidden="true"></div>

  <div class="transcript-overlay" id="transcript-overlay" aria-hidden="true" role="dialog" aria-modal="true">
    <div class="transcript-dialog" id="transcript-dialog">
      <header>
        <h2>Transcript → Meeting JSON</h2>
        <button id="btn-transcript-close" class="ghost" type="button" aria-label="Close transcript converter">×</button>
      </header>
      <div class="transcript-grid">
        <div class="transcript-section">
          <label class="small" for="meeting-id">Meeting metadata</label>
          <div class="row small" style="gap:8px;flex-wrap:wrap">
            <input id="meeting-id" placeholder="meeting_id" style="flex:1 1 200px" />
            <input id="meeting-timestamp" placeholder="timestamp (ISO-8601)" style="flex:1 1 220px" />
          </div>
          <input type="file" id="transcript-file" accept=".txt,.md,.vtt,.srt" class="small" />
          <label class="small" for="transcript">Transcript (paste raw text)</label>
          <textarea id="transcript" rows="14" placeholder="Paste the meeting transcript here… Bullets (-, *, 1.) or lines starting with 'Agenda:'/'Topic:' become items. Blank lines split paragraphs."></textarea>
        </div>
        <div class="transcript-section">
          <label class="small" for="transcript-json">Generated meeting JSON</label>
          <textarea id="transcript-json" rows="14" class="mono" placeholder="Converted JSON will appear here after parsing."></textarea>
        </div>
      </div>
      <div class="transcript-actions">
        <button id="btn-parse-transcript" class="primary" type="button">Convert Transcript</button>
        <button class="icon-button" id="btn-transcript-copy" type="button" aria-label="Copy transcript JSON">
          <svg viewBox="0 0 24 24" aria-hidden="true" focusable="false">
            <rect x="9" y="3" width="11" height="14" rx="2"></rect>
            <rect x="4" y="7" width="11" height="14" rx="2"></rect>
          </svg>
        </button>
        <button id="btn-transcript-download" type="button">Download JSON</button>
        <button id="btn-transcript-fill" type="button">Send to Step 1</button>
      </div>
      <div class="transcript-note">
        Recognizes bullets, numbered lists, and “Agenda:”/“Topic:” headers. You can tweak the JSON before copying or filling Step 1.
      </div>
    </div>
  </div>

  <div class="example-overlay" id="example-overlay" aria-hidden="true">
    <div class="example-dialog" role="dialog" aria-modal="true" aria-labelledby="examples-title">
      <header>
        <h2 id="examples-title">Choose a sample meeting</h2>
        <button id="btn-example-close" class="ghost" type="button" aria-label="Close examples">×</button>
      </header>
      <p class="example-intro">Pick one of the curated Summer of Protocols sessions to populate Step 1, then continue through the flow yourself.</p>
      <div class="example-grid" id="example-grid" role="list"></div>
    </div>
  </div>

<script>
(() => {
  const encoder = new TextEncoder();

  const $ = (sel) => document.querySelector(sel);
  const feed = document.getElementById('feed');
  const rootCode = document.getElementById('root');
  const out = document.getElementById('output');
  const jsonBox = document.getElementById('json');
  const dot = document.getElementById('integrity-dot');
  const integrityLabel = document.getElementById('integrity-label');
  const itemsOverview = document.getElementById('items-overview');
  const btnTryIt = document.getElementById('btn-try-it');
  const btnSaltGenerate = document.getElementById('btn-salt-generate');
  const btnSlackCopy = document.getElementById('btn-slack-copy');
  const btnProofCopy = document.getElementById('btn-proof-copy');
  const btnProofDownload = document.getElementById('btn-proof-download');
  const exampleOverlay = document.getElementById('example-overlay');
  const exampleGrid = document.getElementById('example-grid');
  const btnExampleClose = document.getElementById('btn-example-close');
  const COPY_ICON = `
    <svg viewBox="0 0 24 24" aria-hidden="true" focusable="false">
      <rect x="9" y="3" width="11" height="14" rx="2"></rect>
      <rect x="4" y="7" width="11" height="14" rx="2"></rect>
    </svg>
  `;

  function isPlainObject(value) {
    return value !== null && typeof value === 'object' && !Array.isArray(value);
  }

  function canonicalizeString(value, field) {
    if (typeof value !== 'string') {
      throw new Error(`${field} must be a string`);
    }
    return value.replace(/\r\n?/g, '\n');
  }

  function canonicalizeOptionalString(value, field) {
    if (value === undefined) {
      return undefined;
    }
    return canonicalizeString(value, field);
  }

  function validateTimestamp(value, field) {
    if (Number.isNaN(Date.parse(value))) {
      throw new Error(`${field} must be an ISO-8601 timestamp`);
    }
    return value;
  }

  function normalizeMeetingObject(raw, saltOverride) {
    if (!isPlainObject(raw)) {
      throw new Error('Minutes JSON must be an object.');
    }
    const meeting_id = canonicalizeString(raw.meeting_id, 'meeting_id');
    const timestamp = validateTimestamp(canonicalizeString(raw.timestamp, 'timestamp'), 'timestamp');
    const salt = saltOverride !== undefined && saltOverride !== ''
      ? canonicalizeString(saltOverride, 'salt')
      : canonicalizeOptionalString(raw.salt, 'salt');
    const itemsValue = raw.items;
    if (!Array.isArray(itemsValue)) {
      throw new Error('Items must be an array of {agenda, notes}.');
    }
    if (itemsValue.length === 0) {
      throw new Error('No agenda items found. Add at least one {agenda, notes} pair.');
    }
    const items = itemsValue.map((entry, index) => {
      if (!isPlainObject(entry)) {
        throw new Error(`items[${index}] must be an object`);
      }
      return {
        agenda: canonicalizeString(entry.agenda, `items[${index}].agenda`),
        notes: canonicalizeString(entry.notes, `items[${index}].notes`),
      };
    });
    return { meeting_id, timestamp, salt, items };
  }

  function bytesToHex(bytes) {
    return Array.from(bytes, (byte) => byte.toString(16).padStart(2, '0')).join('');
  }

  function hexToBytes(hex) {
    if (typeof hex !== 'string' || hex.length % 2 !== 0 || !/^[0-9a-f]*$/i.test(hex)) {
      throw new Error('Hex value must be an even-length hexadecimal string.');
    }
    const array = new Uint8Array(hex.length / 2);
    for (let i = 0; i < hex.length; i += 2) {
      array[i / 2] = Number.parseInt(hex.slice(i, i + 2), 16);
    }
    return array;
  }

  async function hashBytes(bytes) {
    const buffer = await crypto.subtle.digest('SHA-256', bytes);
    return new Uint8Array(buffer);
  }

  async function hashUtf8(text) {
    return hashBytes(encoder.encode(text));
  }

  async function hashLeaf(item, salt) {
    const payload = salt ? `${salt}\n${item.agenda}\n${item.notes}` : `${item.agenda}\n${item.notes}`;
    return hashUtf8(payload);
  }

  async function hashInternal(left, right) {
    const combined = new Uint8Array(left.length + right.length);
    combined.set(left, 0);
    combined.set(right, left.length);
    return hashBytes(combined);
  }

  async function buildLevels(items, salt) {
    let current = await Promise.all(items.map((item) => hashLeaf(item, salt)));
    const levels = [current];
    while (current.length > 1) {
      const pairs = [];
      for (let i = 0; i < current.length; i += 2) {
        const left = current[i];
        const right = current[i + 1] ?? current[i];
        pairs.push(hashInternal(left, right));
      }
      current = await Promise.all(pairs);
      levels.push(current);
    }
    return levels;
  }

  async function buildTree(items, salt) {
    const levels = await buildLevels(items, salt);
    return {
      levels,
      leaves: levels[0].map(bytesToHex),
      root: bytesToHex(levels[levels.length - 1][0]),
      levelCounts: levels.map((level) => level.length),
    };
  }

  async function buildTreeFromData(data, saltOverride) {
    const meeting = normalizeMeetingObject(data, saltOverride);
    const tree = await buildTree(meeting.items, meeting.salt);
    return { meeting, tree };
  }

  function generateProofFromLevels(levels, index) {
    const proof = [];
    let currentIndex = index;
    for (let level = 0; level < levels.length - 1; level += 1) {
      const layer = levels[level];
      const isRight = currentIndex % 2 === 1;
      const siblingIndex = isRight ? currentIndex - 1 : currentIndex + 1;
      const sibling = layer[siblingIndex] ?? layer[currentIndex];
      proof.push({
        position: isRight ? 'left' : 'right',
        hash: bytesToHex(sibling),
      });
      currentIndex = Math.floor(currentIndex / 2);
    }
    return proof;
  }

  function normalizeProofStep(entry, index) {
    if (!isPlainObject(entry)) {
      throw new Error(`Proof step ${index} must be an object`);
    }
    const position = entry.position;
    if (position !== 'left' && position !== 'right') {
      throw new Error(`Proof step ${index} must specify position "left" or "right"`);
    }
    const hash = entry.hash;
    if (typeof hash !== 'string') {
      throw new Error(`Proof step ${index} must include a hash string`);
    }
    if (!/^[0-9a-f]{64}$/i.test(hash)) {
      throw new Error(`Proof step ${index} hash must be a 32-byte hex string`);
    }
    return { position, hash: hash.toLowerCase() };
  }

  async function reduceProof(leafBytes, proofSteps) {
    let current = leafBytes;
    for (const step of proofSteps) {
      const sibling = hexToBytes(step.hash);
      // eslint-disable-next-line no-await-in-loop
      current = step.position === 'left'
        ? await hashInternal(sibling, current)
        : await hashInternal(current, sibling);
    }
    return current;
  }

  async function computeRootArtifacts(data, options = {}) {
    const { meeting, tree } = await buildTreeFromData(data, options.salt);
    return { meeting, tree };
  }

  const defaultApi = {
    async computeRoot(data, options = {}) {
      const { meeting, tree } = await computeRootArtifacts(data, options);
      return {
        root: tree.root,
        leafCount: tree.leaves.length,
        levelCounts: tree.levelCounts,
        leaves: tree.leaves,
        meeting,
      };
    },
    async verifyRoot(data, expectedRoot, options = {}) {
      const target = (expectedRoot || '').toLowerCase();
      if (!/^[0-9a-f]{64}$/.test(target)) {
        throw new Error('Expected root must be a 32-byte hex string.');
      }
      const { meeting, tree } = await computeRootArtifacts(data, options);
      return {
        match: tree.root === target,
        computedRoot: tree.root,
        leafCount: tree.leaves.length,
        levelCounts: tree.levelCounts,
        leaves: tree.leaves,
        meeting,
      };
    },
    async generateProof(data, index, options = {}) {
      if (!Number.isInteger(index) || index < 0) {
        throw new Error('Index must be a non-negative integer');
      }
      const { meeting, tree } = await computeRootArtifacts(data, options);
      if (index >= meeting.items.length) {
        throw new Error(`Index ${index} is out of bounds for items array of length ${meeting.items.length}`);
      }
      const proof = generateProofFromLevels(tree.levels, index);
      const document = {
        meeting_id: meeting.meeting_id,
        timestamp: meeting.timestamp,
        salt: meeting.salt,
        index,
        item: meeting.items[index],
        leaf: tree.leaves[index],
        proof,
        root: tree.root,
      };
      return { document, pathLength: proof.length };
    },
    async verifyProof(proofDoc, expectedRoot) {
      if (!isPlainObject(proofDoc)) {
        throw new Error('Proof must be a JSON object');
      }
      const canonical = normalizeMeetingObject({
        meeting_id: proofDoc.meeting_id,
        timestamp: proofDoc.timestamp,
        salt: proofDoc.salt,
        items: [proofDoc.item],
      });
      const canonicalItem = canonical.items[0];
      const canonicalLeaf = bytesToHex(await hashLeaf(canonicalItem, canonical.salt));
      const providedLeaf = typeof proofDoc.leaf === 'string' ? proofDoc.leaf.toLowerCase() : '';
      if (canonicalLeaf !== providedLeaf) {
        return {
          valid: false,
          reason: 'leaf-mismatch',
          computedLeaf: canonicalLeaf,
          providedLeaf,
        };
      }
      if (!Array.isArray(proofDoc.proof)) {
        throw new Error('Proof proof must be an array');
      }
      const proofSteps = proofDoc.proof.map((entry, idx) => normalizeProofStep(entry, idx));
      const leafBytes = hexToBytes(canonicalLeaf);
      const computedRootBytes = await reduceProof(leafBytes, proofSteps);
      const computedRoot = bytesToHex(computedRootBytes);
      const targetRoot = (expectedRoot || proofDoc.root || '').toLowerCase();
      if (!/^[0-9a-f]{64}$/.test(targetRoot)) {
        throw new Error('Expected root must be a 32-byte hex string.');
      }
      return {
        valid: computedRoot === targetRoot,
        computedRoot,
        expectedRoot: targetRoot,
      };
    },
  };

  const resolveApi = () => window.MerkleMeet || window.MeetingMerkle || defaultApi;

  if (!window.MerkleMeet && !window.MeetingMerkle) {
    window.MerkleMeet = defaultApi;
  }

  if (!window.MeetingMerkle) {
    window.MeetingMerkle = window.MerkleMeet;
  }

  const log = (msg, cls = '') => {
    const placeholder = document.getElementById('empty-line');
    if (placeholder) {
      placeholder.remove();
    }
    const line = document.createElement('div');
    line.className = `line ${cls}`.trim();
    line.textContent = msg;
    feed.appendChild(line);
    feed.scrollTop = feed.scrollHeight;
  };

  const copy = async (text) => {
    if (!text) {
      log('> nothing to copy', 'bad');
      return;
    }
    try {
      await navigator.clipboard.writeText(text);
      log('> copied to clipboard', 'ok');
    } catch (error) {
      log('> clipboard not available', 'bad');
    }
  };

  const notWired = (fn) => {
    log(`> ${fn} not wired. Provide window.MerkleMeet.${fn}()`, 'bad');
  };

  const themeToggle = document.getElementById('theme-toggle');
  const THEME_KEY = 'merkle-meet-theme';
  const THEME_ICONS = {
    light: `
      <svg viewBox="0 0 24 24" aria-hidden="true" focusable="false">
        <circle cx="12" cy="12" r="4.5" fill="none"></circle>
        <line x1="12" y1="2" x2="12" y2="5"></line>
        <line x1="12" y1="19" x2="12" y2="22"></line>
        <line x1="4.22" y1="4.22" x2="6.34" y2="6.34"></line>
        <line x1="17.66" y1="17.66" x2="19.78" y2="19.78"></line>
        <line x1="2" y1="12" x2="5" y2="12"></line>
        <line x1="19" y1="12" x2="22" y2="12"></line>
        <line x1="4.22" y1="19.78" x2="6.34" y2="17.66"></line>
        <line x1="17.66" y1="6.34" x2="19.78" y2="4.22"></line>
      </svg>`,
    dark: `
      <svg viewBox="0 0 24 24" aria-hidden="true" focusable="false">
        <path d="M21 12.79A9 9 0 0111.21 3a7 7 0 109.79 9.79z" fill="none"></path>
      </svg>`,
  };

  const applyTheme = (theme) => {
    const normalized = theme === 'light' ? 'light' : 'dark';
    if (normalized === 'light') {
      document.documentElement.setAttribute('data-theme', 'light');
    } else {
      document.documentElement.removeAttribute('data-theme');
    }
    try {
      localStorage.setItem(THEME_KEY, normalized);
    } catch (_) {
      /* ignore storage failures */
    }
    if (themeToggle) {
      const icon = normalized === 'light' ? THEME_ICONS.light : THEME_ICONS.dark;
      const nextTheme = normalized === 'light' ? 'dark' : 'light';
      const label = `Switch to ${nextTheme} theme`;
      themeToggle.innerHTML = icon;
      themeToggle.setAttribute('aria-label', label);
      themeToggle.setAttribute('title', label);
      themeToggle.setAttribute('aria-pressed', normalized === 'light' ? 'true' : 'false');
      themeToggle.dataset.theme = normalized;
    }
  };

  const storedTheme = (() => {
    try {
      return localStorage.getItem(THEME_KEY);
    } catch (_) {
      return null;
    }
  })();
  const prefersDark = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
  applyTheme(storedTheme ?? (prefersDark ? 'dark' : 'light'));

  themeToggle?.addEventListener('click', () => {
    const current = themeToggle.dataset.theme || (document.documentElement.getAttribute('data-theme') === 'light' ? 'light' : 'dark');
    const next = current === 'light' ? 'dark' : 'light';
    applyTheme(next);
    log(`> theme set to ${next}`, 'ok');
  });

  function setIntegrity(state, message) {
    dot.classList.remove('ok', 'bad');
    integrityLabel?.classList.remove('ok', 'error');

    if (state === 'ok') {
      dot.classList.add('ok');
      if (integrityLabel) {
        integrityLabel.textContent = message || 'Root ready';
        integrityLabel.classList.add('ok');
      }
      dot.setAttribute('aria-label', 'Integrity status: root verified');
    } else if (state === 'bad') {
      dot.classList.add('bad');
      if (integrityLabel) {
        integrityLabel.textContent = message || 'Root mismatch';
        integrityLabel.classList.add('error');
      }
      dot.setAttribute('aria-label', 'Integrity status: root mismatch');
    } else {
      if (integrityLabel) {
        integrityLabel.textContent = message || '';
      }
      dot.setAttribute('aria-label', 'Integrity status: idle');
    }
  }

  function stepLog(step, message, cls = '') {
    log(`${step} ▸ ${message}`, cls);
  }

  function updateAgendaList() {
    if (!itemsOverview) return;
    let parsed;
    try {
      parsed = JSON.parse(jsonBox.value || 'null');
    } catch (_) {
      itemsOverview.innerHTML = '<div class="small" data-empty>Agenda items appear here after loading minutes.</div>';
      return;
    }
    if (parsed && typeof parsed === 'object' && typeof parsed.salt === 'string' && parsed.salt && !saltInput.value) {
      saltInput.value = parsed.salt;
    }
    const items = parsed && Array.isArray(parsed.items) ? parsed.items : [];
    if (!items.length) {
      itemsOverview.innerHTML = '<div class="small" data-empty>No agenda items detected yet.</div>';
      if (proofIndexInput) {
        proofIndexInput.value = '';
      }
      return;
    }

    if (selectedProofIndex >= items.length) {
      selectedProofIndex = 0;
    }

    const fragment = document.createDocumentFragment();
    items.forEach((item, index) => {
      const label = document.createElement('label');
      const radio = document.createElement('input');
      radio.type = 'radio';
      radio.name = 'proof-item';
      radio.value = String(index);
      if (index === selectedProofIndex) {
        radio.checked = true;
      }
      radio.addEventListener('change', () => {
        selectedProofIndex = Number.parseInt(radio.value, 10);
        proofIndexInput.value = String(selectedProofIndex);
      });

      const content = document.createElement('div');
      content.className = 'item-body';
      const title = document.createElement('span');
      title.className = 'item-title';
      title.textContent = item.agenda || `Item ${index}`;
      const notes = document.createElement('span');
      notes.className = 'item-notes';
      notes.textContent = (item.notes || '').slice(0, 120);

      content.appendChild(title);
      if (item.notes) {
        content.appendChild(notes);
      }

      label.appendChild(radio);
      label.appendChild(content);
      fragment.appendChild(label);
    });

    itemsOverview.innerHTML = '';
    itemsOverview.appendChild(fragment);
    if (proofIndexInput) {
      proofIndexInput.value = String(selectedProofIndex);
    }
  }

  function resetFeedChecklist() {
    if (!feed) return;
    feed.innerHTML = '<ul class="small" id="empty-line"><li>1. Load or convert minutes JSON.</li><li>2. Compute the Merkle root (salt optional).</li><li>3. Share or verify proofs as needed.</li></ul>';
  }

  function getDesiredProofIndex() {
    const checked = itemsOverview?.querySelector('input[name="proof-item"]:checked');
    if (checked) {
      return Number.parseInt(checked.value, 10);
    }
    const manual = Number.parseInt(proofIndexInput.value, 10);
    return Number.isInteger(manual) && manual >= 0 ? manual : null;
  }

  function parseMeetingInput({ logSuccess = true } = {}) {
    let data;
    try {
      data = JSON.parse(jsonBox.value);
      if (logSuccess) {
        stepLog('Step 1', 'Parsed minutes JSON', 'ok');
      }
      return data;
    } catch (error) {
      stepLog('Step 1', "Couldn't parse JSON. Check for trailing commas or mismatched quotes.", 'bad');
      return null;
    }
  }

  async function computeRootFlow({ meetingOverride } = {}) {
    const meetingData = meetingOverride || parseMeetingInput();
    if (!meetingData) {
      return null;
    }

    if (meetingData.salt && !saltInput.value) {
      saltInput.value = meetingData.salt;
    }

    const api = resolveApi();
    if (!api?.computeRoot) {
      notWired('computeRoot');
      return null;
    }

    try {
      const salt = saltInput.value.trim() || meetingData.salt || undefined;
      stepLog('Step 2', 'Canonicalizing JSON … OK', 'ok');
      const result = await api.computeRoot(meetingData, { salt });
      stepLog('Step 2', `Hashing ${result.leafCount} items with SHA-256 … OK`, 'ok');
      stepLog('Step 2', `Merkle levels: ${result.levelCounts.join(' → ')}`, 'ok');
      stepLog('Step 2', `ROOT = ${result.root} (hex)`, 'ok');
      rootCode.textContent = result.root;
      latestMeeting = result;
      setIntegrity('ok', 'Root computed');
      updateAgendaList();
      return result;
    } catch (error) {
      stepLog('Step 2', `computeRoot failed: ${error.message || error}`, 'bad');
      setIntegrity('bad', 'Root failed');
      return null;
    }
  }

  async function generateProofFlow(index, { meetingOverride } = {}) {
    const meetingData = meetingOverride || parseMeetingInput({ logSuccess: false });
    if (!meetingData) {
      return null;
    }
    if (!Number.isInteger(index) || index < 0) {
      stepLog('Step 5', 'Select an agenda item first (use the radio list).', 'bad');
      return null;
    }
    if (!Array.isArray(meetingData.items) || index >= meetingData.items.length) {
      stepLog('Step 5', 'Item index is out of bounds for the current minutes.', 'bad');
      return null;
    }
    const api = resolveApi();
    if (!api?.generateProof) {
      notWired('generateProof');
      return null;
    }
    try {
      const salt = saltInput.value.trim() || meetingData.salt || undefined;
      const result = await api.generateProof(meetingData, index, { salt });
      const agenda = meetingData.items[index]?.agenda ?? `Item #${index}`;
      stepLog('Step 5', `Generated proof for “${agenda}” (path length = ${result.pathLength})`, 'ok');
      out.value = JSON.stringify(result.document, null, 2);
      latestProofDocument = result.document;
      selectedProofIndex = index;
      proofIndexInput.value = String(index);
      updateAgendaList();
      return result;
    } catch (error) {
      stepLog('Step 5', `generateProof failed: ${error.message || error}`, 'bad');
      return null;
    }
  }

  async function verifyProofDocumentFlow(proofDoc, expectedRoot, { addSummary = true } = {}) {
    const api = resolveApi();
    if (!api?.verifyProof) {
      notWired('verifyProof');
      return { valid: false };
    }
    try {
      const result = await api.verifyProof(proofDoc, expectedRoot);
      if (result.valid) {
        setIntegrity('ok', 'Proof verified');
        stepLog('Step 6', 'Proof matches the expected root', 'ok');
        if (addSummary && proofDoc?.item) {
          const summary = `This proof shows that “${proofDoc.item.agenda}” was part of meeting ${proofDoc.meeting_id} at ${proofDoc.timestamp}.`;
          stepLog('Step 6', summary, 'ok');
          out.value = `${JSON.stringify(proofDoc, null, 2)}\n\n${summary}`;
        }
      } else {
        setIntegrity('bad', 'Mismatch vs expected root');
        stepLog('Step 6', 'Proof did not match the expected root', 'bad');
      }
      return result;
    } catch (error) {
      stepLog('Step 6', `verifyProof failed: ${error.message || error}`, 'bad');
      setIntegrity('bad', 'Proof failed');
      return { valid: false };
    }
  }

  function prepareSlackMessage(meeting, root) {
    return [
      'Merkle Meet 🛡️',
      `Meeting: ${meeting.meeting_id || '—'}`,
      `Timestamp: ${meeting.timestamp || '—'}`,
      `Merkle Root: ${root}`,
      '',
      'Anyone can verify locally: compute the root from the minutes JSON and compare to the above.',
    ].join('\n');
  }

  function downloadJsonFile(filename, data) {
    const blob = new Blob([data], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const link = document.createElement('a');
    link.href = url;
    link.download = filename;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    URL.revokeObjectURL(url);
  }

  const exampleDefaultId = 'protocol-art';
  const exampleSets = [
    {
      id: 'protocol-art',
      title: 'Protocol Art Salon',
      summary: 'Foundations of protocol art, historical references, and taxonomy axes.',
      meeting: {
        meeting_id: 'Protocol-Art-Salon-2025-09-17',
        timestamp: '2025-09-17T18:00:00Z',
        salt: 'sop-demo-protocol-art',
        items: [
          { agenda: 'Define protocol art foundations', notes: 'Explored the shift from autographic works to allographic collaborations and the orchestrator role of artists.' },
          { agenda: 'Historical references', notes: 'Discussed Moholy-Nagy telephone pictures, Sol LeWitt wall drawings, and instruction-driven performance protocols.' },
          { agenda: 'Digital mediums', notes: 'Covered collaborative canvases, generative AI voice models, and smart-contract choreography as protocol art.' },
          { agenda: 'Taxonomy axes', notes: 'Mapped atomic→systemic, strict→fluid, and technical→social spectrums for categorizing protocol art.' },
        ],
      },
    },
    {
      id: 'protocol-fiction',
      title: 'Protocol Fiction Workshop',
      summary: 'Protocol-driven storytelling framework and breakout structure for sci-fi narratives.',
      meeting: {
        meeting_id: 'Protocol-Fiction-Workshop-2025-09-17',
        timestamp: '2025-09-17T16:00:00Z',
        salt: 'sop-demo-protocol-fiction',
        items: [
          { agenda: 'Workshop framing', notes: 'Outlined protocol fiction as shared author-reader conventions plus hierarchy of narrative protocol difficulty.' },
          { agenda: 'Causal layer analysis', notes: 'Reviewed the four-layer method using “The Golden Elephant” as a case study to connect surface, system, worldview, and myth.' },
          { agenda: 'Breakout structure', notes: 'Walked through Seed→Root→Flower→Fruit rounds and concepts like neural interface privacy and AI legal houses.' },
          { agenda: 'Assignments and deliverables', notes: 'Participants to submit a 1,000-word story, documenting AI usage and reflections on co-creation.' },
        ],
      },
    },
    {
      id: 'agentic-web',
      title: 'Agentic Web Trust Protocols',
      summary: 'Trust frameworks for AI agents plus design gaps and experience layers.',
      meeting: {
        meeting_id: 'Agentic-Web-Trust-2025-09-18',
        timestamp: '2025-09-18T15:00:00Z',
        salt: 'sop-demo-agentic-web',
        items: [
          { agenda: 'Trust frameworks', notes: 'Compared value-based and proof-based trust, plus how technology mediates human relationships.' },
          { agenda: 'Rise of the agentic web', notes: 'Forecasted billions of autonomous AI agents across governance, finance, healthcare, legal, and education domains.' },
          { agenda: 'Protocol gaps', notes: 'Highlighted missing behavior verification, misbehavior handling, and cross-platform interoperability for AI agents.' },
          { agenda: 'Experience design stack', notes: 'Introduced evidence→trust primitives→rituals framework and trust experience dimensions like epistemic verification.' },
        ],
      },
    },
    {
      id: 'llm-roleplay',
      title: 'LLM Role-Playing Lab',
      summary: 'Protocol studies pipeline with LLM simulations and workshop takeaways.',
      meeting: {
        meeting_id: 'LLM-Protocol-Studies-2025-09-16',
        timestamp: '2025-09-16T17:30:00Z',
        salt: 'sop-demo-llm-roleplay',
        items: [
          { agenda: 'Program overview', notes: 'Martin Harrigan outlined integrating protocol studies into blockchain curricula and workshop goals.' },
          { agenda: 'Analysis pipeline', notes: 'Reviewed transcription of Summer of Protocols content, embeddings, and clustered concept outputs.' },
          { agenda: 'Evaluation framework', notes: 'Enumerated ten protocol properties and role-playing workflow for testing defensibility and mortality.' },
          { agenda: 'Exercise learnings', notes: 'Captured strengths, weaknesses, and participant observations from the LLM simulations.' },
        ],
      },
    },
  ];

  function closeExampleOverlay() {
    if (!exampleOverlay) return;
    exampleOverlay.classList.remove('open');
    exampleOverlay.setAttribute('aria-hidden', 'true');
    if (!transcriptOverlay?.classList.contains('open')) {
      document.body.classList.remove('modal-open');
    }
  }

  function openExampleOverlay() {
    if (!exampleOverlay) return;
    closeTranscriptOverlay();
    renderExampleCards();
    exampleOverlay.classList.add('open');
    exampleOverlay.setAttribute('aria-hidden', 'false');
    document.body.classList.add('modal-open');
    const defaultButton = document.getElementById(`example-load-${exampleDefaultId}`);
    defaultButton?.focus();
  }

  function loadExampleMeeting(meeting, { stepLabel = 'Step 1' } = {}) {
    jsonBox.value = JSON.stringify(meeting, null, 2);
    saltInput.value = meeting.salt || '';
    selectedProofIndex = 0;
    if (proofIndexInput) {
      proofIndexInput.value = '';
    }
    latestProofDocument = null;
    latestMeeting = null;
    rootCode.textContent = '—';
    out.value = '';
    resetFeedChecklist();
    updateAgendaList();
    if (itemsOverview) {
      itemsOverview.scrollTop = 0;
    }
    setIntegrity(null);
    stepLog(stepLabel, `Loaded example minutes: ${meeting.meeting_id}`, 'ok');
    stepLog(stepLabel, 'Next: Step 2 → Compute the Merkle root.', '');
    closeExampleOverlay();
  }

  function renderExampleCards() {
    if (!exampleGrid || exampleGrid.dataset.rendered === 'true') {
      return;
    }
    exampleGrid.innerHTML = '';
    exampleSets.forEach((entry) => {
      const card = document.createElement('article');
      card.className = 'example-card';
      card.id = `example-card-${entry.id}`;
      card.setAttribute('role', 'listitem');

      const title = document.createElement('h3');
      title.textContent = entry.title;
      const meta = document.createElement('p');
      meta.className = 'small mono';
      meta.textContent = `${entry.meeting.meeting_id} • ${entry.meeting.timestamp}`;
      const summary = document.createElement('p');
      summary.textContent = entry.summary;

      const agendaPreview = document.createElement('p');
      agendaPreview.className = 'small';
      agendaPreview.textContent = entry.meeting.items.slice(0, 2).map((item) => `• ${item.agenda}`).join('   ');

      const footer = document.createElement('footer');
      const loadButton = document.createElement('button');
      loadButton.className = 'primary';
      loadButton.id = `example-load-${entry.id}`;
      loadButton.type = 'button';
      loadButton.textContent = 'Load into Step 1';
      loadButton.addEventListener('click', () => {
        loadExampleMeeting(entry.meeting, { stepLabel: 'Step 1' });
      });

      const copyButton = document.createElement('button');
      copyButton.type = 'button';
      copyButton.classList.add('icon-button');
      copyButton.setAttribute('aria-label', 'Copy JSON');
      copyButton.innerHTML = COPY_ICON;
      copyButton.addEventListener('click', () => {
        copy(JSON.stringify(entry.meeting, null, 2));
        stepLog('Step 1', `Copied ${entry.meeting.meeting_id} JSON`, 'ok');
      });

      footer.appendChild(loadButton);
      footer.appendChild(copyButton);

      card.appendChild(title);
      card.appendChild(meta);
      card.appendChild(summary);
      card.appendChild(agendaPreview);
      card.appendChild(footer);
      exampleGrid.appendChild(card);
    });
    exampleGrid.dataset.rendered = 'true';
  }

  btnExampleClose?.addEventListener('click', () => {
    closeExampleOverlay();
  });

  exampleOverlay?.addEventListener('click', (event) => {
    if (event.target === exampleOverlay) {
      closeExampleOverlay();
    }
  });

  const stepDetails = Array.from(document.querySelectorAll('.step'));
  const stepHelpButtons = document.querySelectorAll('.step-help');
  let selectedProofIndex = 0;
  let latestProofDocument = null;
  let latestMeeting = null;
  let lastTranscriptItemsCount = 0;
  let agendaDebounce;

  stepHelpButtons.forEach((button) => {
    button.addEventListener('click', () => {
      const targetId = button.dataset.help;
      const target = targetId ? document.getElementById(targetId) : null;
      if (target) {
        target.classList.toggle('visible');
      }
    });
  });

  stepDetails.forEach((detail) => {
    detail.addEventListener('toggle', () => {
      if (detail.open) {
        detail.dataset.userOpen = 'true';
      }
    });
  });

  const accordionQuery = window.matchMedia('(max-width: 900px)');
  const syncAccordion = () => {
    if (accordionQuery.matches) {
      stepDetails.forEach((detail, index) => {
        if (!detail.dataset.userOpen) {
          detail.open = index === 0;
        }
      });
    } else {
      stepDetails.forEach((detail) => {
        detail.open = true;
        delete detail.dataset.userOpen;
      });
    }
  };
  if (typeof accordionQuery.addEventListener === 'function') {
    accordionQuery.addEventListener('change', syncAccordion);
  } else if (typeof accordionQuery.addListener === 'function') {
    accordionQuery.addListener(syncAccordion);
  }
  syncAccordion();

  const btnExample = document.getElementById('btn-example');
  const btnClear = document.getElementById('btn-clear');
  const btnCopyRoot = document.getElementById('btn-copy-root');
  const btnRoot = document.getElementById('btn-root');
  const btnSlack = document.getElementById('btn-slack');
  const btnVerifyRoot = document.getElementById('btn-verify-root');
  const btnProof = document.getElementById('btn-proof');
  const btnVerifyProof = document.getElementById('btn-verify-proof');
  const btnCopyOutput = document.getElementById('btn-copy-output');
  const proofIndexInput = document.getElementById('proof-index');
  const expectedRootInput = document.getElementById('expected-root');
  const saltInput = document.getElementById('salt');
  const whyLinks = document.querySelectorAll('.why-link');

  // Transcript converter elements
  const transcriptOverlay = document.getElementById('transcript-overlay');
  const btnTranscriptPanel = document.getElementById('btn-transcript-panel');
  const btnTranscriptClose = document.getElementById('btn-transcript-close');
  const btnParseTranscript = document.getElementById('btn-parse-transcript');
  const btnTranscriptCopy = document.getElementById('btn-transcript-copy');
  const btnTranscriptDownload = document.getElementById('btn-transcript-download');
  const btnTranscriptFill = document.getElementById('btn-transcript-fill');
  const meetingIdInput = document.getElementById('meeting-id');
  const meetingTsInput = document.getElementById('meeting-timestamp');
  const transcriptInput = document.getElementById('transcript');
  const transcriptJsonOutput = document.getElementById('transcript-json');
  const transcriptFileInput = document.getElementById('transcript-file');

  btnExample?.addEventListener('click', () => {
    openExampleOverlay();
  });

  btnClear?.addEventListener('click', () => {
    jsonBox.value = '';
    saltInput.value = '';
    out.value = '';
    rootCode.textContent = '—';
    selectedProofIndex = 0;
    updateAgendaList();
    resetFeedChecklist();
    setIntegrity(null);
    stepLog('Step 1', 'Cleared minutes and outputs', 'ok');
  });

  btnSaltGenerate?.addEventListener('click', () => {
    const bytes = new Uint8Array(16);
    crypto.getRandomValues(bytes);
    const salt = Array.from(bytes, (byte) => byte.toString(16).padStart(2, '0')).join('');
    saltInput.value = salt;
    stepLog('Step 2', 'Generated random salt', 'ok');
  });

  btnCopyRoot.addEventListener('click', () => copy(rootCode.textContent));

  jsonBox.addEventListener('input', () => {
    clearTimeout(agendaDebounce);
    agendaDebounce = setTimeout(() => {
      updateAgendaList();
    }, 250);
    setIntegrity(null);
  });

  btnRoot?.addEventListener('click', () => {
    computeRootFlow();
  });

  btnSlack?.addEventListener('click', () => {
    const meeting = parseMeetingInput({ logSuccess: false });
    if (!meeting) {
      return;
    }
    const root = rootCode.textContent;
    if (!root || root === '—') {
      stepLog('Step 3', 'Compute a root before composing the Slack message.', 'bad');
      return;
    }
    const message = prepareSlackMessage(meeting, root);
    out.value = message;
    stepLog('Step 3', 'Slack message prepared', 'ok');
  });

  btnSlackCopy?.addEventListener('click', () => {
    if (!out.value.trim()) {
      stepLog('Step 3', 'Compose a Slack message first', 'bad');
      return;
    }
    copy(out.value);
    stepLog('Step 3', 'Slack message copied to clipboard', 'ok');
  });

  btnVerifyRoot?.addEventListener('click', async () => {
    const data = parseMeetingInput({ logSuccess: false });
    if (!data) {
      return;
    }
    const expected = expectedRootInput.value.trim();
    if (!expected) {
      stepLog('Step 4', 'Enter an expected root to compare against.', 'bad');
      return;
    }
    const api = resolveApi();
    if (!api?.verifyRoot) {
      notWired('verifyRoot');
      return;
    }
    try {
      const salt = saltInput.value.trim() || data.salt || undefined;
      const result = await api.verifyRoot(data, expected, { salt });
      stepLog('Step 4', result.match ? 'Root matches the expected value' : 'Root mismatch detected', result.match ? 'ok' : 'bad');
      rootCode.textContent = result.computedRoot;
      setIntegrity(result.match ? 'ok' : 'bad', result.match ? 'Root matches expected root' : 'Mismatch vs expected root');
    } catch (error) {
      stepLog('Step 4', `verifyRoot failed: ${error.message || error}`, 'bad');
      setIntegrity('bad', 'Verification failed');
    }
  });

  btnProof?.addEventListener('click', () => {
    const index = getDesiredProofIndex();
    if (index === null) {
      stepLog('Step 5', 'Select an agenda item from the list or enter an index.', 'bad');
      return;
    }
    generateProofFlow(index);
  });

  btnProofCopy?.addEventListener('click', () => {
    if (!latestProofDocument) {
      stepLog('Step 5', 'Generate a proof before copying.', 'bad');
      return;
    }
    copy(JSON.stringify(latestProofDocument, null, 2));
    stepLog('Step 5', 'Proof JSON copied to clipboard', 'ok');
  });

  btnProofDownload?.addEventListener('click', () => {
    if (!latestProofDocument) {
      stepLog('Step 5', 'Generate a proof before downloading.', 'bad');
      return;
    }
    const fileName = `${(latestProofDocument.meeting_id || 'meeting').replace(/[^a-z0-9\-]+/gi, '_')}-proof.json`;
    downloadJsonFile(fileName, JSON.stringify(latestProofDocument, null, 2));
    stepLog('Step 5', 'Downloaded proof.json', 'ok');
  });

  btnTryIt?.addEventListener('click', () => {
    openExampleOverlay();
    stepLog('Demo', 'Pick an example meeting, then continue with Step 2 to compute the root.', 'ok');
  });

  btnVerifyProof?.addEventListener('click', async () => {
    let proof;
    try {
      proof = JSON.parse(out.value);
      stepLog('Step 6', 'Parsed proof JSON', 'ok');
    } catch (error) {
      stepLog('Step 6', 'Paste a proof JSON into Output first.', 'bad');
      return;
    }
    latestProofDocument = proof;
    const displayedRoot = rootCode.textContent;
    const expected = displayedRoot && displayedRoot !== '—' ? displayedRoot : undefined;
    await verifyProofDocumentFlow(proof, expected);
  });

  btnCopyOutput.addEventListener('click', () => copy(out.value));

  // ===== Transcript → JSON helpers =====
  function defaultMeetingId() {
    const d = new Date();
    const yyyy = d.getFullYear();
    const mm = String(d.getMonth()+1).padStart(2, '0');
    const dd = String(d.getDate()).padStart(2, '0');
    return `Meeting-${yyyy}-${mm}-${dd}`;
  }

  function ensureMeetingDefaults() {
    if (meetingIdInput && !meetingIdInput.value) {
      meetingIdInput.value = defaultMeetingId();
    }
    if (meetingTsInput && !meetingTsInput.value) {
      meetingTsInput.value = new Date().toISOString();
    }
  }

  function firstSentence(str) {
    const s = String(str || '').replace(/\s+/g, ' ').trim();
    if (!s) return '';
    const m = s.match(/^(.{1,140}?[\.\!\?])\s/);
    return (m ? m[1] : s.slice(0, 80));
  }

  function parseTranscriptToItems(text) {
    const cleaned = String(text || '').replace(/\r\n?/g, '\n').trim();
    if (!cleaned) return [];

    const lines = cleaned.split('\n');

    // Pass 1: marker-based extraction (Agenda:/Topic:/Item:, bullets -,*,•, or numbered 1.)
    const items = [];
    let current = null;
    const flush = () => {
      if (current) {
        const agenda = (current.agenda || '').trim();
        const notes = current.notes.join('\n').trim();
        if (agenda || notes) items.push({ agenda: agenda || firstSentence(notes), notes });
        current = null;
      }
    };

    const agendaRe = /^\s*(?:agenda|topic|item)\s*[:\-]\s*(.+)$/i;
    const bulletRe = /^\s*(?:[\-\*\u2022]|[0-9]{1,2}\.)\s+(.+)$/;

    for (const raw of lines) {
      const line = raw.trimRight();
      if (!line.trim()) { // allow blank lines inside notes; they help the paragraph fallback
        if (current) current.notes.push('');
        continue;
      }
      let m;
      if ((m = line.match(agendaRe))) {
        flush();
        current = { agenda: m[1].trim(), notes: [] };
        continue;
      }
      if ((m = line.match(bulletRe))) {
        flush();
        current = { agenda: m[1].trim(), notes: [] };
        continue;
      }
      // speaker timestamp lines like "[00:10] Alice: ..."
      // treat as note content
      if (!current) {
        current = { agenda: firstSentence(line), notes: [line] };
      } else {
        current.notes.push(line);
      }
    }
    flush();

    if (items.length > 0) {
      return items.slice(0, 100); // guardrail: max 100 items
    }

    // Pass 2: paragraph-based fallback (split by blank lines)
    const paragraphs = cleaned.split(/\n\s*\n+/).map(p => p.trim()).filter(Boolean);
    const paraItems = paragraphs.map(p => ({ agenda: firstSentence(p), notes: p }));
    return paraItems.slice(0, 100);
  }

  function openTranscriptOverlay() {
    ensureMeetingDefaults();
    closeExampleOverlay();
    if (!transcriptOverlay?.classList.contains('open')) {
      transcriptOverlay.classList.add('open');
      document.body.classList.add('modal-open');
      transcriptOverlay.setAttribute('aria-hidden', 'false');
      log('> transcript converter opened');
    }
  }

  function closeTranscriptOverlay() {
    if (transcriptOverlay?.classList.contains('open')) {
      transcriptOverlay.classList.remove('open');
      if (!exampleOverlay?.classList.contains('open')) {
        document.body.classList.remove('modal-open');
      }
      transcriptOverlay.setAttribute('aria-hidden', 'true');
      log('> transcript converter closed');
    }
  }

  btnTranscriptPanel?.addEventListener('click', () => {
    openTranscriptOverlay();
  });

  btnTranscriptClose?.addEventListener('click', () => {
    closeTranscriptOverlay();
  });

  transcriptOverlay?.addEventListener('click', (event) => {
    if (event.target === transcriptOverlay) {
      closeTranscriptOverlay();
    }
  });

  document.addEventListener('keydown', (event) => {
    if (event.key !== 'Escape') {
      return;
    }
    if (transcriptOverlay?.classList.contains('open')) {
      closeTranscriptOverlay();
      return;
    }
    if (exampleOverlay?.classList.contains('open')) {
      closeExampleOverlay();
    }
  });

  transcriptFileInput?.addEventListener('change', async (e) => {
    const f = e.target.files && e.target.files[0];
    if (!f) return;
    const text = await f.text().catch(() => '');
    if (text) {
      transcriptInput.value = text;
      stepLog('Step 0', `Loaded transcript file ${f.name}`, 'ok');
    } else {
      stepLog('Step 0', 'Failed to read transcript file', 'bad');
    }
  });

  btnParseTranscript?.addEventListener('click', () => {
    const text = transcriptInput?.value || '';
    if (!text.trim()) {
      stepLog('Step 0', 'Paste a transcript first', 'bad');
      return;
    }
    ensureMeetingDefaults();
    const items = parseTranscriptToItems(text);
    if (!items.length) {
      stepLog('Step 0', 'Could not detect bullet markers; falling back to paragraphs', 'bad');
    }
    const meeting_id = (meetingIdInput?.value || '').trim() || defaultMeetingId();
    const timestamp = (meetingTsInput?.value || '').trim() || new Date().toISOString();
    const salt = (saltInput?.value || '').trim();
    const meeting = Object.assign({ meeting_id, timestamp, items }, salt ? { salt } : {});
    const json = JSON.stringify(meeting, null, 2);
    if (transcriptJsonOutput) {
      transcriptJsonOutput.value = json;
    }
    lastTranscriptItemsCount = items.length;
    stepLog('Step 0', `Converted transcript into ${items.length || 1} item${items.length === 1 ? '' : 's'} of meeting JSON`, 'ok');
  });

  btnTranscriptCopy?.addEventListener('click', () => {
    if (!transcriptJsonOutput?.value.trim()) {
      stepLog('Step 0', 'Convert transcript before copying', 'bad');
      return;
    }
    copy(transcriptJsonOutput.value);
    stepLog('Step 0', 'Transcript JSON copied to clipboard', 'ok');
  });

  btnTranscriptDownload?.addEventListener('click', () => {
    const payload = transcriptJsonOutput?.value.trim();
    if (!payload) {
      stepLog('Step 0', 'Convert transcript before downloading', 'bad');
      return;
    }
    const baseName = (meetingIdInput?.value || defaultMeetingId()).replace(/[^a-z0-9\-]+/gi, '_') || 'meeting';
    downloadJsonFile(`${baseName}.json`, payload);
    stepLog('Step 0', 'Downloaded meeting JSON', 'ok');
  });

  btnTranscriptFill?.addEventListener('click', async () => {
    const payload = transcriptJsonOutput?.value.trim();
    if (!payload) {
      stepLog('Step 0', 'Convert transcript before sending to Step 1', 'bad');
      return;
    }
    try {
      const parsed = JSON.parse(payload);
      lastTranscriptItemsCount = Array.isArray(parsed.items) ? parsed.items.length : 0;
    } catch (_) {
      lastTranscriptItemsCount = 0;
    }
    jsonBox.value = payload;
    updateAgendaList();
    setIntegrity(null);
    closeTranscriptOverlay();
    selectedProofIndex = 0;
    stepLog('Step 0', 'Meeting JSON filled into Step 1', 'ok');
    if (lastTranscriptItemsCount > 1) {
      await computeRootFlow();
      const proofResult = await generateProofFlow(0);
      if (proofResult) {
        const step5 = document.getElementById('step-5');
        const step6 = document.getElementById('step-6');
        if (step5) step5.open = true;
        if (step6) step6.open = true;
        stepLog('Step 5', 'Auto-generated proof for the first item from transcript', 'ok');
      }
    }
  });

  whyLinks.forEach((link) => {
    link.addEventListener('click', (event) => {
      event.preventDefault();
      out.value = [
        'Why salting matters:',
        '- Without a salt, a guessable phrase might be brute-checked against a hash.',
        '- Adding a random per-meeting salt makes hashes unique and unguessable.',
        '- Include the salt in each item leaf derivation, or in the meeting metadata.',
      ].join('\n');
      stepLog('Step 2', 'Opened salting note', 'ok');
    });
  });

  resetFeedChecklist();
  updateAgendaList();
  setIntegrity(null);
})();
</script>
</body>
</html>
