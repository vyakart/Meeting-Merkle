<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Merkle-Meet ‚Äî Tamper-evident, privacy-preserving minutes</title>
<link rel="icon" href="data:,">
<style>
:root{
  color-scheme: dark;
  --bg: #0b0f14;
  --panel: #0d131a;
  --ink: #e7f8ff;
  --muted: #9fb0bf;
  --accent: #00ffd1;
  --accent-2: #ff00a8;
  --danger: #ff4d6d;
  --ok: #3dfc9a;
  --mono: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace;

  --br: 10px;
  --glow: 0 0 6px rgba(0,255,209,.35), 0 0 24px rgba(255,0,168,.18);
  --line: 1px solid rgba(255,255,255,.06);
  --border-weak: rgba(255,255,255,.12);
  --border-strong: rgba(255,255,255,.24);
  --feed-border: rgba(0,255,209,.18);
  --feed-bg: rgba(9,16,23,.92);
  --feed-text: #c8ffef;
  --input-bg: #0a0f14;
  --button-bg: #0b1218;
  --body-gradient: radial-gradient(1200px 600px at 80% 0%, rgba(255,0,168,.07), transparent 40%),
                   radial-gradient(1000px 700px at 0% 100%, rgba(0,255,209,.07), transparent 40%),
                   var(--bg);
}

[data-theme="light"]{
  color-scheme: light;
  --bg: #f6f8fb;
  --panel: #ffffff;
  --ink: #0b111a;
  --muted: #4c6072;
  --accent: #0066ff;
  --accent-2: #ff3fb4;
  --danger: #d42a4a;
  --ok: #158a4c;
  --glow: 0 0 6px rgba(0,102,255,.25), 0 0 24px rgba(255,63,180,.15);
  --line: 1px solid rgba(8,16,24,.08);
  --border-weak: rgba(11,17,26,.14);
  --border-strong: rgba(11,17,26,.28);
  --feed-border: rgba(0,102,255,.18);
  --feed-bg: rgba(237,242,250,.92);
  --feed-text: #17324a;
  --input-bg: #eef2f8;
  --button-bg: #f5f7fb;
  --body-gradient: radial-gradient(1200px 600px at 80% 0%, rgba(0,102,255,.08), transparent 40%),
                   radial-gradient(1000px 700px at 0% 100%, rgba(255,63,180,.08), transparent 40%),
                   var(--bg);
}
*{box-sizing:border-box}
html,body{height:100%}
body{
  margin:0; background: var(--body-gradient);
  color:var(--ink); font-family: var(--mono); letter-spacing:.2px;
}
.header{
  padding:16px 20px; border-bottom: var(--line); display:flex; align-items:center; gap:12px;
  background: linear-gradient(180deg, rgba(255,255,255,.03), rgba(255,255,255,0));
}
.brand{
  font-weight:700; font-size:18px; letter-spacing:.6px;
}
.tagline{color:var(--muted); font-size:12px}

.badge{
  margin-left:8px; padding:4px 10px; border:1px solid var(--border-weak);
  border-radius:999px; color:var(--muted); display:flex; align-items:center; gap:8px;
}
.status-chip{
  padding:2px 10px;
  border-radius:999px;
  font-size:11px;
  letter-spacing:.3px;
  border:1px solid transparent;
  display:inline-flex;
  align-items:center;
  gap:6px;
  text-transform:uppercase;
}
.status-chip.ok{background:rgba(0,255,209,.12);color:var(--ok);border-color:rgba(0,255,209,.35);}
.status-chip.error{background:rgba(255,77,109,.12);color:var(--danger);border-color:rgba(255,77,109,.35);}
.status-chip.neutral{background:rgba(255,255,255,.06);color:var(--muted);border-color:var(--border-weak);}
.grid{
  display:grid; grid-template-columns: 320px 1fr; gap:16px; padding:16px; height:calc(100% - 58px);
}
.sidebar{
  background: var(--panel); border: var(--line); border-radius: var(--br); padding:12px; overflow:auto;
}
.step{
  border-radius:8px;
  border:1px dashed rgba(255,255,255,.08);
  margin-bottom:10px;
  background:rgba(255,255,255,.02);
}
.step summary{
  cursor:pointer;
  list-style:none;
  padding:8px 10px;
  font-size:13px;
  color:var(--accent);
  font-weight:600;
  display:flex;
  align-items:center;
  justify-content:space-between;
  gap:12px;
}
.step summary::-webkit-details-marker{display:none;}
.step .step-body{padding:0 10px 10px 10px;}
.step .step-body p{margin:0 0 8px 0; color:var(--muted); font-size:12px; line-height:1.4}
.step .actions{display:flex; flex-wrap:wrap; gap:6px}
.step-help{
  border:none;
  background:rgba(255,255,255,.08);
  color:var(--muted);
  border-radius:50%;
  width:20px;
  height:20px;
  font-size:12px;
  display:inline-flex;
  align-items:center;
  justify-content:center;
  cursor:pointer;
}
.step-help:focus-visible{outline:2px solid var(--accent);}
.step-helptext{
  display:none;
  font-size:12px;
  color:var(--muted);
  border-left:2px solid rgba(255,255,255,.08);
  padding-left:8px;
  margin-bottom:8px;
}
.step-helptext.visible{display:block;}
button,.btn{
  background:var(--button-bg); color:var(--ink); border:1px solid var(--border-weak);
  padding:8px 10px; border-radius:8px; cursor:pointer; font-family:var(--mono);
}
button:hover{border-color:var(--border-strong)}
button.primary{
  border-color: var(--accent); box-shadow: var(--glow);
}
button.ghost{background:transparent}
#theme-toggle{
  margin-left:auto;
  width:40px;
  height:40px;
  display:flex;
  align-items:center;
  justify-content:center;
  border-radius:12px;
  padding:0;
}
#theme-toggle svg{width:20px;height:20px;display:block;stroke:currentColor;stroke-width:1.5;}
#theme-toggle circle{stroke:currentColor;fill:none;}
#theme-toggle line{stroke:currentColor;stroke-linecap:round;}
#theme-toggle path{stroke:currentColor;stroke-linecap:round;fill:currentColor;stroke-width:1.2;}
input,textarea{
  width:100%; background:var(--input-bg); color:var(--ink); border:1px solid var(--border-weak);
  border-radius:8px; padding:10px; font-family:var(--mono); font-size:12px;
}
label{font-size:12px; color:var(--muted)}
.main{
  display:grid; grid-template-rows: auto 1fr auto; gap:12px; min-height:0;
}
.panel{
  background: var(--panel); border: var(--line); border-radius: var(--br); padding:12px; min-height:0;
}
.hero{
  display:flex; align-items:flex-start; justify-content:space-between; gap:12px;
  position:sticky;
  top:-1px;
  z-index:10;
  background:var(--panel);
  border-bottom:1px solid rgba(255,255,255,.04);
  padding-bottom:12px;
}
.hero .left{display:flex; flex-direction:column; gap:4px}
.hero .title{font-size:16px; font-weight:700}
.hero .subtitle{font-size:12px; color:var(--muted)}
.hero .actions{display:flex; flex-wrap:wrap; gap:8px; align-items:center;}
.kv{
  display:grid; grid-template-columns: 1fr 1fr; gap:12px;
}
.kv .box{display:flex; flex-direction:column; gap:6px}
.feed{
  background:var(--feed-bg); border:1px solid var(--feed-border); border-radius:8px;
  padding:10px; font-size:12px; color:var(--feed-text); height:220px; overflow:auto;
}
.feed .line{white-space:pre-wrap; margin:0 0 4px 0}
.feed .ok{color:var(--ok)}
.feed .bad{color:var(--danger)}
.mono{font-family:var(--mono)}
.row{display:flex; gap:8px; align-items:center}
.small{font-size:12px}
.code{background:#081018; border:1px solid rgba(255,255,255,.12); border-radius:8px; padding:8px; font-size:12px}
.status{
  display:flex; align-items:center; gap:8px; color:var(--muted); font-size:12px
}
.root-readout{margin-top:6px; display:flex; align-items:center; gap:6px; font-size:12px; color:var(--muted); font-family:var(--mono);}
.dot{width:8px;height:8px;border-radius:50%;background:#8b93a0;border:1px solid #444}
.dot.ok{background:var(--ok); box-shadow:0 0 10px rgba(61,252,154,.6)}
.dot.bad{background:var(--danger); box-shadow:0 0 10px rgba(255,77,109,.6)}
.chip-group{display:flex; gap:8px; align-items:center; flex-wrap:wrap;}
.footer{
  display:flex; justify-content:space-between; align-items:center; gap:8px; color:var(--muted); font-size:12px
}
a.link{color:var(--accent)}
hr.div{border:0;border-top:1px solid rgba(255,255,255,.08);margin:8px 0}
.scanlines{
  position:fixed; inset:0; pointer-events:none;
  background: repeating-linear-gradient(0deg, rgba(255,255,255,.02), rgba(255,255,255,.02) 1px, transparent 1px, transparent 3px);
  mix-blend-mode:overlay; opacity:.25;
}
body.modal-open{overflow:hidden;}

.transcript-overlay{
  position:fixed;
  inset:0;
  background:rgba(6,12,18,0.78);
  backdrop-filter:blur(10px);
  display:none;
  align-items:center;
  justify-content:center;
  padding:24px;
  z-index:1000;
}

.transcript-overlay.open{display:flex;}

.transcript-dialog{
  width:min(960px,100%);
  max-height:90vh;
  overflow:auto;
  background:var(--panel);
  border:var(--line);
  border-radius:var(--br);
  padding:20px;
  box-shadow:0 40px 80px rgba(0,0,0,0.45);
  display:flex;
  flex-direction:column;
  gap:16px;
}

.transcript-dialog header{
  display:flex;
  align-items:center;
  justify-content:space-between;
  gap:12px;
}

.transcript-dialog h2{
  margin:0;
  font-size:16px;
  letter-spacing:.4px;
}

.transcript-grid{
  display:grid;
  grid-template-columns:repeat(2,minmax(0,1fr));
  gap:16px;
}

@media (max-width: 960px){
  .transcript-grid{grid-template-columns:1fr;}
}

.transcript-section{
  display:flex;
  flex-direction:column;
  gap:8px;
}

.transcript-actions{
  display:flex;
  flex-wrap:wrap;
  gap:8px;
}

.transcript-note{
  font-size:12px;
  color:var(--muted);
}

.salt-row{display:flex; align-items:center; gap:6px; flex-wrap:wrap;}
.salt-tip{font-size:12px; color:var(--muted); display:flex; align-items:center; gap:6px;}
.salt-tip button{padding:4px 10px; font-size:11px; border-radius:999px;}
.tooltip{position:relative; display:inline-flex; align-items:center;}
.tooltip:hover .tooltip-content,
.tooltip:focus-within .tooltip-content{opacity:1; transform:translateY(0); pointer-events:auto;}
.tooltip-icon{
  width:16px;
  height:16px;
  border-radius:50%;
  background:rgba(255,255,255,.08);
  display:inline-flex;
  align-items:center;
  justify-content:center;
  font-size:11px;
  cursor:pointer;
}
.tooltip-content{
  position:absolute;
  bottom:calc(100% + 6px);
  left:50%;
  transform:translate(-50%, 6px);
  background:var(--panel);
  border:1px solid var(--border-weak);
  border-radius:8px;
  padding:8px 10px;
  font-size:11px;
  color:var(--muted);
  width:220px;
  box-shadow:0 12px 32px rgba(0,0,0,.25);
  opacity:0;
  pointer-events:none;
  transition:opacity .15s ease, transform .15s ease;
  z-index:20;
}
.tooltip-content p{margin:0;}
.tooltip-content a{display:inline-block;margin-top:6px;}

.items-overview{
  border:1px solid var(--border-weak);
  border-radius:10px;
  padding:8px;
  max-height:240px;
  overflow:auto;
  background:rgba(255,255,255,.02);
}
.items-overview label{display:flex; align-items:flex-start; gap:8px; font-size:12px; color:var(--ink); padding:6px 4px; border-radius:6px; cursor:pointer;}
.items-overview label:hover{background:rgba(255,255,255,.04);}
.items-overview input[type="radio"]{margin-top:2px;}
.items-overview .item-notes{display:block; color:var(--muted); font-size:11px; margin-top:2px;}

.proof-actions{display:flex; flex-wrap:wrap; gap:6px; margin-top:6px;}
.feed ul{margin:0;padding-left:18px;}

.hero-sticky-spacer{height:0;}
body.modal-open{overflow:hidden;}

.transcript-overlay{
  position:fixed;
  inset:0;
  background:rgba(6,12,18,0.78);
  backdrop-filter:blur(10px);
  display:none;
  align-items:center;
  justify-content:center;
  padding:24px;
  z-index:1000;
}

.transcript-overlay.open{display:flex;}

.transcript-dialog{
  width:min(960px,100%);
  max-height:90vh;
  overflow:auto;
  background:var(--panel);
  border:var(--line);
  border-radius:var(--br);
  padding:20px;
  box-shadow:0 40px 80px rgba(0,0,0,0.45);
  display:flex;
  flex-direction:column;
  gap:16px;
}

.transcript-dialog header{
  display:flex;
  align-items:center;
  justify-content:space-between;
  gap:12px;
}

.transcript-note{
  font-size:12px;
  color:var(--muted);
}
@media (max-width: 900px){
  .grid{grid-template-columns:1fr}
  .sidebar{order:2;}
  .main{order:1;}
  .kv{grid-template-columns:1fr}
  .hero{top:-1px;}
  .step{border:1px solid rgba(255,255,255,.12);}
}
</style>
</head>
<body>
  <div class="header" role="banner">
    <div class="brand">MERKLE-MEET</div>
    <div class="tagline">Tamper-evident, privacy-preserving minutes</div>
    <button class="ghost" id="theme-toggle" type="button" aria-label="Toggle theme">Light Theme</button>
    <div class="badge" aria-live="polite">
      <span class="dot" id="integrity-dot" title="Integrity badge"></span> integrity
    </div>
  </div>

  <div class="grid" role="main">
    <aside class="sidebar" aria-label="Steps">
      <details class="step" id="step-0-transcript" open>
        <summary>
          <span>Step 0 ‚Äî From Transcript (optional)</span>
          <button class="step-help" type="button" data-help="help-step-0" aria-label="Explain transcript conversion">?</button>
        </summary>
        <div class="step-body">
          <div class="step-helptext" id="help-step-0">Use a raw transcript to auto-build meeting minutes before hashing. The parser extracts agenda lines and notes into structured JSON.</div>
          <p>Drop in a raw transcript, convert to meeting JSON, then copy, download, or fill Step 1 automatically.</p>
          <div class="actions">
            <button class="ghost" id="btn-transcript-panel" type="button">Open Transcript Converter</button>
          </div>
        </div>
      </details>

      <details class="step" id="step-1" open>
        <summary>
          <span>Step 1 ‚Äî Load Minutes</span>
          <button class="step-help" type="button" data-help="help-step-1" aria-label="Explain minutes JSON">?</button>
        </summary>
        <div class="step-body">
          <div class="step-helptext" id="help-step-1">Minutes JSON is the canonical record we hash. Each agenda item becomes a Merkle leaf in the order it appears. Review or edit it before computing the root.</div>
          <p>Paste your minutes JSON. You can load an example to explore.</p>
          <div class="actions">
            <button class="ghost" id="btn-example">Load Example</button>
            <button class="ghost" id="btn-clear">Clear</button>
          </div>
        </div>
      </details>

      <details class="step" id="step-2" open>
        <summary>
          <span>Step 2 ‚Äî Compute Root</span>
          <button class="step-help" type="button" data-help="help-step-2" aria-label="Explain Merkle root">?</button>
        </summary>
        <div class="step-body">
          <div class="step-helptext" id="help-step-2">A Merkle root is a single fingerprint for the entire meeting. Any change to agenda or notes alters the root, making tampering evident.</div>
          <p>Normalize ‚Üí hash items (SHA-256) ‚Üí build Merkle tree.</p>
          <div class="actions">
            <button class="primary" id="btn-root">Compute Root</button>
            <button id="btn-copy-root">Copy Root</button>
          </div>
        </div>
      </details>

      <details class="step" id="step-3" open>
        <summary>
          <span>Step 3 ‚Äî Publish &amp; Share</span>
          <button class="step-help" type="button" data-help="help-step-3" aria-label="Explain publishing the root">?</button>
        </summary>
        <div class="step-body">
          <div class="step-helptext" id="help-step-3">Share the Merkle root (and proof, if needed) with your team. Anyone can recompute the root locally and confirm it matches.</div>
          <p>Post the root where others can see (e.g. Slack).</p>
          <div class="actions">
            <button id="btn-slack">Compose Slack message</button>
            <button id="btn-slack-copy" type="button">Copy Slack message</button>
          </div>
        </div>
      </details>

      <details class="step" id="step-4" open>
        <summary>
          <span>Step 4 ‚Äî Verify Record</span>
          <button class="step-help" type="button" data-help="help-step-4" aria-label="Explain verification">?</button>
        </summary>
        <div class="step-body">
          <div class="step-helptext" id="help-step-4">Verification recomputes the fingerprint from your minutes and checks it against an expected root. Matching roots confirm no changes were made.</div>
          <p>Recompute from JSON and compare to an expected root.</p>
          <div class="actions row">
            <input id="expected-root" placeholder="Expected root (hex)" aria-label="Expected root" />
            <button id="btn-verify-root">Verify Against Root</button>
          </div>
        </div>
      </details>

      <details class="step" id="step-5" open>
        <summary>
          <span>Step 5 ‚Äî Generate Proof</span>
          <button class="step-help" type="button" data-help="help-step-5" aria-label="Explain membership proofs">?</button>
        </summary>
        <div class="step-body">
          <div class="step-helptext" id="help-step-5">A membership proof lets you show one agenda item was part of the meeting without revealing the rest of the notes.</div>
          <p>Select an agenda item (radio list beside the minutes) to generate its inclusion proof.</p>
          <div class="actions row" style="margin-top:6px">
            <input id="proof-index" placeholder="Item index (0-based)" aria-label="Item index (optional)" />
            <button id="btn-proof">Create Proof</button>
          </div>
          <div class="proof-actions">
            <button id="btn-proof-copy" type="button">Copy proof JSON</button>
            <button id="btn-proof-download" type="button">Download proof.json</button>
          </div>
        </div>
      </details>

      <details class="step" id="step-6" open>
        <summary>
          <span>Step 6 ‚Äî Verify Proof</span>
          <button class="step-help" type="button" data-help="help-step-6" aria-label="Explain proof verification">?</button>
        </summary>
        <div class="step-body">
          <div class="step-helptext" id="help-step-6">Proof verification replays the Merkle path to ensure the proof matches the root you trust. If any hash or ordering is wrong, verification fails.</div>
          <p>Check a membership proof against the root.</p>
          <div class="actions">
            <button id="btn-verify-proof">Verify Proof</button>
            <button id="btn-copy-output">Copy Output</button>
          </div>
        </div>
      </details>
    </aside>

    <section class="main">
      <div class="panel hero" aria-live="polite">
        <div class="left">
          <div class="title">Trust the minutes. Not the note-taker.</div>
          <div class="subtitle">All verification is local. No servers. No secrets leaked.</div>
          <div class="actions">
            <button class="primary" id="btn-try-it">Try it now</button>
          </div>
        </div>
        <div class="status">
          <div class="chip-group">
            <span class="dot" id="integrity-dot" aria-label="Integrity status: idle"></span>
            <span class="status-chip neutral" id="root-status-chip">Awaiting root</span>
          </div>
          <div class="root-readout"><span>Root:</span> <code id="root" class="mono">‚Äî</code></div>
        </div>
      </div>

      <div class="panel kv">
        <div class="box">
          <label for="json">Minutes JSON</label>
          <textarea id="json" rows="12" placeholder='Paste your minutes JSON here...'></textarea>
          <div class="salt-row small">
            <div class="row small" style="gap:6px;align-items:center;">
              <label for="salt" style="min-width:80px;margin:0;">Salt (opt.)</label>
              <div class="tooltip">
                <button type="button" class="tooltip-icon" aria-describedby="salt-tooltip">i</button>
                <div class="tooltip-content" role="tooltip" id="salt-tooltip">
                  <p>Salts add randomness so identical minutes produce different hashes.</p>
                  <a href="#" class="why-link">Learn more</a>
                </div>
              </div>
            </div>
            <input id="salt" placeholder="random-16-bytes" aria-label="Salt" />
            <button id="btn-salt-generate" type="button">Generate random salt</button>
          </div>
          <div class="items-overview" id="items-overview" role="radiogroup" aria-live="polite" aria-label="Agenda items"></div>
        </div>

        <div class="box">
          <label>Terminal Feed</label>
          <div class="feed" id="feed" aria-live="polite" aria-atomic="false">
            <ul class="small" id="empty-line">
              <li>1. Load or convert minutes JSON.</li>
              <li>2. Compute the Merkle root (salt optional).</li>
              <li>3. Share or verify proofs as needed.</li>
            </ul>
          </div>
          <hr class="div" />
          <div class="box">
            <label for="output">Output</label>
            <textarea id="output" rows="6" class="mono" placeholder="Proofs, verification results, and composer text appear here."></textarea>
          </div>
        </div>
      </div>

      <div class="panel footer">
        <div>SHA-256 ‚Ä¢ Odd-leaf duplication ‚Ä¢ Canonical JSON ‚Ä¢ Local-only</div>
        <div><a class="link why-link" href="#" id="why-link">Why salting matters</a></div>
      </div>
    </section>
  </div>

  <div class="scanlines" aria-hidden="true"></div>

  <div class="transcript-overlay" id="transcript-overlay" aria-hidden="true" role="dialog" aria-modal="true">
    <div class="transcript-dialog" id="transcript-dialog">
      <header>
        <h2>Transcript ‚Üí Meeting JSON</h2>
        <button id="btn-transcript-close" class="ghost" type="button" aria-label="Close transcript converter">√ó</button>
      </header>
      <div class="transcript-grid">
        <div class="transcript-section">
          <label class="small" for="meeting-id">Meeting metadata</label>
          <div class="row small" style="gap:8px;flex-wrap:wrap">
            <input id="meeting-id" placeholder="meeting_id" style="flex:1 1 200px" />
            <input id="meeting-timestamp" placeholder="timestamp (ISO-8601)" style="flex:1 1 220px" />
          </div>
          <input type="file" id="transcript-file" accept=".txt,.md,.vtt,.srt" class="small" />
          <label class="small" for="transcript">Transcript (paste raw text)</label>
          <textarea id="transcript" rows="14" placeholder="Paste the meeting transcript here‚Ä¶ Bullets (-, *, 1.) or lines starting with 'Agenda:'/'Topic:' become items. Blank lines split paragraphs."></textarea>
        </div>
        <div class="transcript-section">
          <label class="small" for="transcript-json">Generated meeting JSON</label>
          <textarea id="transcript-json" rows="14" class="mono" placeholder="Converted JSON will appear here after parsing."></textarea>
        </div>
      </div>
      <div class="transcript-actions">
        <button id="btn-parse-transcript" class="primary" type="button">Convert Transcript</button>
        <button id="btn-transcript-copy" type="button">Copy JSON</button>
        <button id="btn-transcript-download" type="button">Download JSON</button>
        <button id="btn-transcript-fill" type="button">Send to Step 1</button>
      </div>
      <div class="transcript-note">
        Recognizes bullets, numbered lists, and ‚ÄúAgenda:‚Äù/‚ÄúTopic:‚Äù headers. You can tweak the JSON before copying or filling Step 1.
      </div>
    </div>
  </div>

<script>
(() => {
  const encoder = new TextEncoder();

  const $ = (sel) => document.querySelector(sel);
  const feed = document.getElementById('feed');
  const rootCode = document.getElementById('root');
  const out = document.getElementById('output');
  const jsonBox = document.getElementById('json');
  const dot = document.getElementById('integrity-dot');
  const rootStatusChip = document.getElementById('root-status-chip');
  const itemsOverview = document.getElementById('items-overview');
  const btnTryIt = document.getElementById('btn-try-it');
  const btnSaltGenerate = document.getElementById('btn-salt-generate');
  const btnSlackCopy = document.getElementById('btn-slack-copy');
  const btnProofCopy = document.getElementById('btn-proof-copy');
  const btnProofDownload = document.getElementById('btn-proof-download');

  function isPlainObject(value) {
    return value !== null && typeof value === 'object' && !Array.isArray(value);
  }

  function canonicalizeString(value, field) {
    if (typeof value !== 'string') {
      throw new Error(`${field} must be a string`);
    }
    return value.replace(/\r\n?/g, '\n');
  }

  function canonicalizeOptionalString(value, field) {
    if (value === undefined) {
      return undefined;
    }
    return canonicalizeString(value, field);
  }

  function validateTimestamp(value, field) {
    if (Number.isNaN(Date.parse(value))) {
      throw new Error(`${field} must be an ISO-8601 timestamp`);
    }
    return value;
  }

  function normalizeMeetingObject(raw, saltOverride) {
    if (!isPlainObject(raw)) {
      throw new Error('Minutes JSON must be an object.');
    }
    const meeting_id = canonicalizeString(raw.meeting_id, 'meeting_id');
    const timestamp = validateTimestamp(canonicalizeString(raw.timestamp, 'timestamp'), 'timestamp');
    const salt = saltOverride !== undefined && saltOverride !== ''
      ? canonicalizeString(saltOverride, 'salt')
      : canonicalizeOptionalString(raw.salt, 'salt');
    const itemsValue = raw.items;
    if (!Array.isArray(itemsValue)) {
      throw new Error('Items must be an array of {agenda, notes}.');
    }
    if (itemsValue.length === 0) {
      throw new Error('No agenda items found. Add at least one {agenda, notes} pair.');
    }
    const items = itemsValue.map((entry, index) => {
      if (!isPlainObject(entry)) {
        throw new Error(`items[${index}] must be an object`);
      }
      return {
        agenda: canonicalizeString(entry.agenda, `items[${index}].agenda`),
        notes: canonicalizeString(entry.notes, `items[${index}].notes`),
      };
    });
    return { meeting_id, timestamp, salt, items };
  }

  function bytesToHex(bytes) {
    return Array.from(bytes, (byte) => byte.toString(16).padStart(2, '0')).join('');
  }

  function hexToBytes(hex) {
    if (typeof hex !== 'string' || hex.length % 2 !== 0 || !/^[0-9a-f]*$/i.test(hex)) {
      throw new Error('Hex value must be an even-length hexadecimal string.');
    }
    const array = new Uint8Array(hex.length / 2);
    for (let i = 0; i < hex.length; i += 2) {
      array[i / 2] = Number.parseInt(hex.slice(i, i + 2), 16);
    }
    return array;
  }

  async function hashBytes(bytes) {
    const buffer = await crypto.subtle.digest('SHA-256', bytes);
    return new Uint8Array(buffer);
  }

  async function hashUtf8(text) {
    return hashBytes(encoder.encode(text));
  }

  async function hashLeaf(item, salt) {
    const payload = salt ? `${salt}\n${item.agenda}\n${item.notes}` : `${item.agenda}\n${item.notes}`;
    return hashUtf8(payload);
  }

  async function hashInternal(left, right) {
    const combined = new Uint8Array(left.length + right.length);
    combined.set(left, 0);
    combined.set(right, left.length);
    return hashBytes(combined);
  }

  async function buildLevels(items, salt) {
    let current = await Promise.all(items.map((item) => hashLeaf(item, salt)));
    const levels = [current];
    while (current.length > 1) {
      const next = [];
      for (let i = 0; i < current.length; i += 2) {
        const left = current[i];
        const right = current[i + 1] ?? current[i];
        // eslint-disable-next-line no-await-in-loop
        next.push(await hashInternal(left, right));
      }
      current = next;
      levels.push(current);
    }
    return levels;
  }

  async function buildTree(items, salt) {
    const levels = await buildLevels(items, salt);
    return {
      levels,
      leaves: levels[0].map(bytesToHex),
      root: bytesToHex(levels[levels.length - 1][0]),
      levelCounts: levels.map((level) => level.length),
    };
  }

  async function buildTreeFromData(data, saltOverride) {
    const meeting = normalizeMeetingObject(data, saltOverride);
    const tree = await buildTree(meeting.items, meeting.salt);
    return { meeting, tree };
  }

  function generateProofFromLevels(levels, index) {
    const proof = [];
    let currentIndex = index;
    for (let level = 0; level < levels.length - 1; level += 1) {
      const layer = levels[level];
      const isRight = currentIndex % 2 === 1;
      const siblingIndex = isRight ? currentIndex - 1 : currentIndex + 1;
      const sibling = layer[siblingIndex] ?? layer[currentIndex];
      proof.push({
        position: isRight ? 'left' : 'right',
        hash: bytesToHex(sibling),
      });
      currentIndex = Math.floor(currentIndex / 2);
    }
    return proof;
  }

  function normalizeProofStep(entry, index) {
    if (!isPlainObject(entry)) {
      throw new Error(`Proof step ${index} must be an object`);
    }
    const position = entry.position;
    if (position !== 'left' && position !== 'right') {
      throw new Error(`Proof step ${index} must specify position "left" or "right"`);
    }
    const hash = entry.hash;
    if (typeof hash !== 'string') {
      throw new Error(`Proof step ${index} must include a hash string`);
    }
    if (!/^[0-9a-f]{64}$/i.test(hash)) {
      throw new Error(`Proof step ${index} hash must be a 32-byte hex string`);
    }
    return { position, hash: hash.toLowerCase() };
  }

  async function reduceProof(leafBytes, proofSteps) {
    let current = leafBytes;
    for (const step of proofSteps) {
      const sibling = hexToBytes(step.hash);
      // eslint-disable-next-line no-await-in-loop
      current = step.position === 'left'
        ? await hashInternal(sibling, current)
        : await hashInternal(current, sibling);
    }
    return current;
  }

  const defaultApi = {
    async computeRoot(data, options = {}) {
      const { meeting, tree } = await buildTreeFromData(data, options.salt);
      return {
        root: tree.root,
        leafCount: tree.leaves.length,
        levelCounts: tree.levelCounts,
        leaves: tree.leaves,
        meeting,
      };
    },
    async verifyRoot(data, expectedRoot, options = {}) {
      const target = (expectedRoot || '').toLowerCase();
      if (!/^[0-9a-f]{64}$/.test(target)) {
        throw new Error('Expected root must be a 32-byte hex string.');
      }
      const result = await this.computeRoot(data, options);
      return {
        match: result.root === target,
        computedRoot: result.root,
        leafCount: result.leafCount,
        levelCounts: result.levelCounts,
        leaves: result.leaves,
        meeting: result.meeting,
      };
    },
    async generateProof(data, index, options = {}) {
      if (!Number.isInteger(index) || index < 0) {
        throw new Error('Index must be a non-negative integer');
      }
      const { meeting, tree } = await buildTreeFromData(data, options.salt);
      if (index >= meeting.items.length) {
        throw new Error(`Index ${index} is out of bounds for items array of length ${meeting.items.length}`);
      }
      const proof = generateProofFromLevels(tree.levels, index);
      const document = {
        meeting_id: meeting.meeting_id,
        timestamp: meeting.timestamp,
        salt: meeting.salt,
        index,
        item: meeting.items[index],
        leaf: tree.leaves[index],
        proof,
        root: tree.root,
      };
      return { document, pathLength: proof.length };
    },
    async verifyProof(proofDoc, expectedRoot) {
      if (!isPlainObject(proofDoc)) {
        throw new Error('Proof must be a JSON object');
      }
      const canonical = normalizeMeetingObject({
        meeting_id: proofDoc.meeting_id,
        timestamp: proofDoc.timestamp,
        salt: proofDoc.salt,
        items: [proofDoc.item],
      });
      const canonicalItem = canonical.items[0];
      const canonicalLeaf = bytesToHex(await hashLeaf(canonicalItem, canonical.salt));
      const providedLeaf = typeof proofDoc.leaf === 'string' ? proofDoc.leaf.toLowerCase() : '';
      if (canonicalLeaf !== providedLeaf) {
        return {
          valid: false,
          reason: 'leaf-mismatch',
          computedLeaf: canonicalLeaf,
          providedLeaf,
        };
      }
      if (!Array.isArray(proofDoc.proof)) {
        throw new Error('Proof proof must be an array');
      }
      const proofSteps = proofDoc.proof.map((entry, idx) => normalizeProofStep(entry, idx));
      const leafBytes = hexToBytes(canonicalLeaf);
      const computedRootBytes = await reduceProof(leafBytes, proofSteps);
      const computedRoot = bytesToHex(computedRootBytes);
      const targetRoot = (expectedRoot || proofDoc.root || '').toLowerCase();
      if (!/^[0-9a-f]{64}$/.test(targetRoot)) {
        throw new Error('Expected root must be a 32-byte hex string.');
      }
      return {
        valid: computedRoot === targetRoot,
        computedRoot,
        expectedRoot: targetRoot,
      };
    },
  };

  const resolveApi = () => window.MerkleMeet || window.MeetingMerkle || defaultApi;

  if (!window.MerkleMeet && !window.MeetingMerkle) {
    window.MerkleMeet = defaultApi;
  }

  if (!window.MeetingMerkle) {
    window.MeetingMerkle = window.MerkleMeet;
  }

  const log = (msg, cls = '') => {
    const placeholder = document.getElementById('empty-line');
    if (placeholder) {
      placeholder.remove();
    }
    const line = document.createElement('div');
    line.className = `line ${cls}`.trim();
    line.textContent = msg;
    feed.appendChild(line);
    feed.scrollTop = feed.scrollHeight;
  };

  const copy = async (text) => {
    if (!text) {
      log('> nothing to copy', 'bad');
      return;
    }
    try {
      await navigator.clipboard.writeText(text);
      log('> copied to clipboard', 'ok');
    } catch (error) {
      log('> clipboard not available', 'bad');
    }
  };

  const notWired = (fn) => {
    log(`> ${fn} not wired. Provide window.MerkleMeet.${fn}()`, 'bad');
  };

  const themeToggle = document.getElementById('theme-toggle');
  const THEME_KEY = 'merkle-meet-theme';
  const THEME_ICONS = {
    light: `
      <svg viewBox="0 0 24 24" aria-hidden="true" focusable="false">
        <circle cx="12" cy="12" r="4.5" fill="none"></circle>
        <line x1="12" y1="2" x2="12" y2="5"></line>
        <line x1="12" y1="19" x2="12" y2="22"></line>
        <line x1="4.22" y1="4.22" x2="6.34" y2="6.34"></line>
        <line x1="17.66" y1="17.66" x2="19.78" y2="19.78"></line>
        <line x1="2" y1="12" x2="5" y2="12"></line>
        <line x1="19" y1="12" x2="22" y2="12"></line>
        <line x1="4.22" y1="19.78" x2="6.34" y2="17.66"></line>
        <line x1="17.66" y1="6.34" x2="19.78" y2="4.22"></line>
      </svg>`,
    dark: `
      <svg viewBox="0 0 24 24" aria-hidden="true" focusable="false">
        <path d="M21 12.79A9 9 0 0111.21 3a7 7 0 109.79 9.79z" fill="none"></path>
      </svg>`,
  };

  const applyTheme = (theme) => {
    const normalized = theme === 'light' ? 'light' : 'dark';
    if (normalized === 'light') {
      document.documentElement.setAttribute('data-theme', 'light');
    } else {
      document.documentElement.removeAttribute('data-theme');
    }
    try {
      localStorage.setItem(THEME_KEY, normalized);
    } catch (_) {
      /* ignore storage failures */
    }
    if (themeToggle) {
      const icon = normalized === 'light' ? THEME_ICONS.light : THEME_ICONS.dark;
      const nextTheme = normalized === 'light' ? 'dark' : 'light';
      const label = `Switch to ${nextTheme} theme`;
      themeToggle.innerHTML = icon;
      themeToggle.setAttribute('aria-label', label);
      themeToggle.setAttribute('title', label);
      themeToggle.setAttribute('aria-pressed', normalized === 'light' ? 'true' : 'false');
      themeToggle.dataset.theme = normalized;
    }
  };

  const storedTheme = (() => {
    try {
      return localStorage.getItem(THEME_KEY);
    } catch (_) {
      return null;
    }
  })();
  const prefersDark = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
  applyTheme(storedTheme ?? (prefersDark ? 'dark' : 'light'));

  themeToggle?.addEventListener('click', () => {
    const current = themeToggle.dataset.theme || (document.documentElement.getAttribute('data-theme') === 'light' ? 'light' : 'dark');
    const next = current === 'light' ? 'dark' : 'light';
    applyTheme(next);
    log(`> theme set to ${next}`, 'ok');
  });

  function setIntegrity(state, message) {
    const stateLabel = {
      neutral: message || 'Awaiting root',
      ok: message || 'Verified',
      bad: message || 'Mismatch vs expected root',
    };

    dot.classList.remove('ok', 'bad');
    rootStatusChip?.classList.remove('ok', 'error', 'neutral');

    if (state === 'ok') {
      dot.classList.add('ok');
      rootStatusChip?.classList.add('ok');
      rootStatusChip.textContent = stateLabel.ok;
      dot.setAttribute('aria-label', `Integrity status: ${stateLabel.ok.toLowerCase()}`);
    } else if (state === 'bad') {
      dot.classList.add('bad');
      rootStatusChip?.classList.add('error');
      rootStatusChip.textContent = stateLabel.bad;
      dot.setAttribute('aria-label', `Integrity status: ${stateLabel.bad.toLowerCase()}`);
    } else {
      rootStatusChip?.classList.add('neutral');
      rootStatusChip.textContent = stateLabel.neutral;
      dot.setAttribute('aria-label', 'Integrity status: awaiting root');
    }
  }

  function stepLog(step, message, cls = '') {
    log(`${step} ‚ñ∏ ${message}`, cls);
  }

  function updateAgendaList() {
    if (!itemsOverview) return;
    let parsed;
    try {
      parsed = JSON.parse(jsonBox.value || 'null');
    } catch (_) {
      itemsOverview.innerHTML = '<div class="small" data-empty>Agenda items appear here after loading minutes.</div>';
      return;
    }
    if (parsed && typeof parsed === 'object' && typeof parsed.salt === 'string' && parsed.salt && !saltInput.value) {
      saltInput.value = parsed.salt;
    }
    const items = parsed && Array.isArray(parsed.items) ? parsed.items : [];
    if (!items.length) {
      itemsOverview.innerHTML = '<div class="small" data-empty>No agenda items detected yet.</div>';
      if (proofIndexInput) {
        proofIndexInput.value = '';
      }
      return;
    }

    if (selectedProofIndex >= items.length) {
      selectedProofIndex = 0;
    }

    const fragment = document.createDocumentFragment();
    items.forEach((item, index) => {
      const label = document.createElement('label');
      const radio = document.createElement('input');
      radio.type = 'radio';
      radio.name = 'proof-item';
      radio.value = String(index);
      if (index === selectedProofIndex) {
        radio.checked = true;
      }
      radio.addEventListener('change', () => {
        selectedProofIndex = Number.parseInt(radio.value, 10);
        proofIndexInput.value = String(selectedProofIndex);
      });

      const content = document.createElement('div');
      const title = document.createElement('span');
      title.textContent = item.agenda || `Item ${index}`;
      const notes = document.createElement('span');
      notes.className = 'item-notes';
      notes.textContent = (item.notes || '').slice(0, 120);

      content.appendChild(title);
      if (item.notes) {
        content.appendChild(notes);
      }

      label.appendChild(radio);
      label.appendChild(content);
      fragment.appendChild(label);
    });

    itemsOverview.innerHTML = '';
    itemsOverview.appendChild(fragment);
    if (proofIndexInput) {
      proofIndexInput.value = String(selectedProofIndex);
    }
  }

  function resetFeedChecklist() {
    if (!feed) return;
    feed.innerHTML = '<ul class="small" id="empty-line"><li>1. Load or convert minutes JSON.</li><li>2. Compute the Merkle root (salt optional).</li><li>3. Share or verify proofs as needed.</li></ul>';
  }

  function getDesiredProofIndex() {
    const checked = itemsOverview?.querySelector('input[name="proof-item"]:checked');
    if (checked) {
      return Number.parseInt(checked.value, 10);
    }
    const manual = Number.parseInt(proofIndexInput.value, 10);
    return Number.isInteger(manual) && manual >= 0 ? manual : null;
  }

  function parseMeetingInput({ logSuccess = true } = {}) {
    let data;
    try {
      data = JSON.parse(jsonBox.value);
      if (logSuccess) {
        stepLog('Step 1', 'Parsed minutes JSON', 'ok');
      }
      return data;
    } catch (error) {
      stepLog('Step 1', "Couldn't parse JSON. Check for trailing commas or mismatched quotes.", 'bad');
      return null;
    }
  }

  async function computeRootFlow({ meetingOverride } = {}) {
    const meetingData = meetingOverride || parseMeetingInput();
    if (!meetingData) {
      return null;
    }

    if (meetingData.salt && !saltInput.value) {
      saltInput.value = meetingData.salt;
    }

    const api = resolveApi();
    if (!api?.computeRoot) {
      notWired('computeRoot');
      return null;
    }

    try {
      const salt = saltInput.value.trim() || meetingData.salt || undefined;
      stepLog('Step 2', 'Canonicalizing JSON ‚Ä¶ OK', 'ok');
      const result = await api.computeRoot(meetingData, { salt });
      stepLog('Step 2', `Hashing ${result.leafCount} items with SHA-256 ‚Ä¶ OK`, 'ok');
      stepLog('Step 2', `Merkle levels: ${result.levelCounts.join(' ‚Üí ')}`, 'ok');
      stepLog('Step 2', `ROOT = ${result.root} (hex)`, 'ok');
      rootCode.textContent = result.root;
      latestMeeting = result;
      setIntegrity('ok', 'Root computed');
      updateAgendaList();
      return result;
    } catch (error) {
      stepLog('Step 2', `computeRoot failed: ${error.message || error}`, 'bad');
      setIntegrity('bad', 'Root failed');
      return null;
    }
  }

  async function generateProofFlow(index, { meetingOverride } = {}) {
    const meetingData = meetingOverride || parseMeetingInput({ logSuccess: false });
    if (!meetingData) {
      return null;
    }
    if (!Number.isInteger(index) || index < 0) {
      stepLog('Step 5', 'Select an agenda item first (use the radio list).', 'bad');
      return null;
    }
    if (!Array.isArray(meetingData.items) || index >= meetingData.items.length) {
      stepLog('Step 5', 'Item index is out of bounds for the current minutes.', 'bad');
      return null;
    }
    const api = resolveApi();
    if (!api?.generateProof) {
      notWired('generateProof');
      return null;
    }
    try {
      const salt = saltInput.value.trim() || meetingData.salt || undefined;
      const result = await api.generateProof(meetingData, index, { salt });
      const agenda = meetingData.items[index]?.agenda ?? `Item #${index}`;
      stepLog('Step 5', `Generated proof for ‚Äú${agenda}‚Äù (path length = ${result.pathLength})`, 'ok');
      out.value = JSON.stringify(result.document, null, 2);
      latestProofDocument = result.document;
      selectedProofIndex = index;
      proofIndexInput.value = String(index);
      updateAgendaList();
      return result;
    } catch (error) {
      stepLog('Step 5', `generateProof failed: ${error.message || error}`, 'bad');
      return null;
    }
  }

  async function verifyProofDocumentFlow(proofDoc, expectedRoot, { addSummary = true } = {}) {
    const api = resolveApi();
    if (!api?.verifyProof) {
      notWired('verifyProof');
      return { valid: false };
    }
    try {
      const result = await api.verifyProof(proofDoc, expectedRoot);
      if (result.valid) {
        setIntegrity('ok', 'Proof verified');
        stepLog('Step 6', 'Proof matches the expected root', 'ok');
        if (addSummary && proofDoc?.item) {
          const summary = `This proof shows that ‚Äú${proofDoc.item.agenda}‚Äù was part of meeting ${proofDoc.meeting_id} at ${proofDoc.timestamp}.`;
          stepLog('Step 6', summary, 'ok');
          out.value = `${JSON.stringify(proofDoc, null, 2)}\n\n${summary}`;
        }
      } else {
        setIntegrity('bad', 'Mismatch vs expected root');
        stepLog('Step 6', 'Proof did not match the expected root', 'bad');
      }
      return result;
    } catch (error) {
      stepLog('Step 6', `verifyProof failed: ${error.message || error}`, 'bad');
      setIntegrity('bad', 'Proof failed');
      return { valid: false };
    }
  }

  function prepareSlackMessage(meeting, root) {
    return [
      'Merkle Meet üõ°Ô∏è',
      `Meeting: ${meeting.meeting_id || '‚Äî'}`,
      `Timestamp: ${meeting.timestamp || '‚Äî'}`,
      `Merkle Root: ${root}`,
      '',
      'Anyone can verify locally: compute the root from the minutes JSON and compare to the above.',
    ].join('\n');
  }

  function downloadJsonFile(filename, data) {
    const blob = new Blob([data], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const link = document.createElement('a');
    link.href = url;
    link.download = filename;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    URL.revokeObjectURL(url);
  }

  const example = {
    meeting_id: 'DAO-Council-Meeting-2025-09-17',
    timestamp: '2025-09-17T14:00:00Z',
    salt: 'optional-random-string',
    items: [
      { agenda: 'Budget Allocation for Q4', notes: 'Allocate 500 DAO tokens to the community fund.' },
      { agenda: 'Project X Update', notes: 'Reviewed progress; deadline extended to Nov 30.' },
      { agenda: 'New Member Onboarding', notes: 'Discussed process; no formal resolution.' },
    ],
  };

  const stepDetails = Array.from(document.querySelectorAll('.step'));
  const stepHelpButtons = document.querySelectorAll('.step-help');
  let selectedProofIndex = 0;
  let latestProofDocument = null;
  let latestMeeting = null;
  let lastTranscriptItemsCount = 0;
  let agendaDebounce;

  stepHelpButtons.forEach((button) => {
    button.addEventListener('click', () => {
      const targetId = button.dataset.help;
      const target = targetId ? document.getElementById(targetId) : null;
      if (target) {
        target.classList.toggle('visible');
      }
    });
  });

  stepDetails.forEach((detail) => {
    detail.addEventListener('toggle', () => {
      if (detail.open) {
        detail.dataset.userOpen = 'true';
      }
    });
  });

  const accordionQuery = window.matchMedia('(max-width: 900px)');
  const syncAccordion = () => {
    if (accordionQuery.matches) {
      stepDetails.forEach((detail, index) => {
        if (!detail.dataset.userOpen) {
          detail.open = index === 0;
        }
      });
    } else {
      stepDetails.forEach((detail) => {
        detail.open = true;
        delete detail.dataset.userOpen;
      });
    }
  };
  if (typeof accordionQuery.addEventListener === 'function') {
    accordionQuery.addEventListener('change', syncAccordion);
  } else if (typeof accordionQuery.addListener === 'function') {
    accordionQuery.addListener(syncAccordion);
  }
  syncAccordion();

  const btnExample = document.getElementById('btn-example');
  const btnClear = document.getElementById('btn-clear');
  const btnCopyRoot = document.getElementById('btn-copy-root');
  const btnRoot = document.getElementById('btn-root');
  const btnSlack = document.getElementById('btn-slack');
  const btnVerifyRoot = document.getElementById('btn-verify-root');
  const btnProof = document.getElementById('btn-proof');
  const btnVerifyProof = document.getElementById('btn-verify-proof');
  const btnCopyOutput = document.getElementById('btn-copy-output');
  const proofIndexInput = document.getElementById('proof-index');
  const expectedRootInput = document.getElementById('expected-root');
  const saltInput = document.getElementById('salt');
  const whyLinks = document.querySelectorAll('.why-link');

  // Transcript converter elements
  const transcriptOverlay = document.getElementById('transcript-overlay');
  const btnTranscriptPanel = document.getElementById('btn-transcript-panel');
  const btnTranscriptClose = document.getElementById('btn-transcript-close');
  const btnParseTranscript = document.getElementById('btn-parse-transcript');
  const btnTranscriptCopy = document.getElementById('btn-transcript-copy');
  const btnTranscriptDownload = document.getElementById('btn-transcript-download');
  const btnTranscriptFill = document.getElementById('btn-transcript-fill');
  const meetingIdInput = document.getElementById('meeting-id');
  const meetingTsInput = document.getElementById('meeting-timestamp');
  const transcriptInput = document.getElementById('transcript');
  const transcriptJsonOutput = document.getElementById('transcript-json');
  const transcriptFileInput = document.getElementById('transcript-file');

  btnExample?.addEventListener('click', () => {
    jsonBox.value = JSON.stringify(example, null, 2);
    saltInput.value = example.salt || '';
    selectedProofIndex = 0;
    updateAgendaList();
    rootCode.textContent = '‚Äî';
    out.value = '';
    setIntegrity(null);
    stepLog('Step 1', 'Loaded example minutes', 'ok');
  });

  btnClear?.addEventListener('click', () => {
    jsonBox.value = '';
    saltInput.value = '';
    out.value = '';
    rootCode.textContent = '‚Äî';
    selectedProofIndex = 0;
    updateAgendaList();
    resetFeedChecklist();
    setIntegrity(null);
    stepLog('Step 1', 'Cleared minutes and outputs', 'ok');
  });

  btnSaltGenerate?.addEventListener('click', () => {
    const bytes = new Uint8Array(16);
    crypto.getRandomValues(bytes);
    const salt = Array.from(bytes, (byte) => byte.toString(16).padStart(2, '0')).join('');
    saltInput.value = salt;
    stepLog('Step 2', 'Generated random salt', 'ok');
  });

  btnCopyRoot.addEventListener('click', () => copy(rootCode.textContent));

  jsonBox.addEventListener('input', () => {
    clearTimeout(agendaDebounce);
    agendaDebounce = setTimeout(() => {
      updateAgendaList();
    }, 250);
    setIntegrity(null);
  });

  btnRoot?.addEventListener('click', () => {
    computeRootFlow();
  });

  btnSlack?.addEventListener('click', () => {
    const meeting = parseMeetingInput({ logSuccess: false });
    if (!meeting) {
      return;
    }
    const root = rootCode.textContent;
    if (!root || root === '‚Äî') {
      stepLog('Step 3', 'Compute a root before composing the Slack message.', 'bad');
      return;
    }
    const message = prepareSlackMessage(meeting, root);
    out.value = message;
    stepLog('Step 3', 'Slack message prepared', 'ok');
  });

  btnSlackCopy?.addEventListener('click', () => {
    if (!out.value.trim()) {
      stepLog('Step 3', 'Compose a Slack message first', 'bad');
      return;
    }
    copy(out.value);
    stepLog('Step 3', 'Slack message copied to clipboard', 'ok');
  });

  btnVerifyRoot?.addEventListener('click', async () => {
    const data = parseMeetingInput({ logSuccess: false });
    if (!data) {
      return;
    }
    const expected = expectedRootInput.value.trim();
    if (!expected) {
      stepLog('Step 4', 'Enter an expected root to compare against.', 'bad');
      return;
    }
    const api = resolveApi();
    if (!api?.verifyRoot) {
      notWired('verifyRoot');
      return;
    }
    try {
      const salt = saltInput.value.trim() || data.salt || undefined;
      const result = await api.verifyRoot(data, expected, { salt });
      stepLog('Step 4', result.match ? 'Root matches the expected value' : 'Root mismatch detected', result.match ? 'ok' : 'bad');
      rootCode.textContent = result.computedRoot;
      setIntegrity(result.match ? 'ok' : 'bad', result.match ? 'Root matches expected root' : 'Mismatch vs expected root');
    } catch (error) {
      stepLog('Step 4', `verifyRoot failed: ${error.message || error}`, 'bad');
      setIntegrity('bad', 'Verification failed');
    }
  });

  btnProof?.addEventListener('click', () => {
    const index = getDesiredProofIndex();
    if (index === null) {
      stepLog('Step 5', 'Select an agenda item from the list or enter an index.', 'bad');
      return;
    }
    generateProofFlow(index);
  });

  btnProofCopy?.addEventListener('click', () => {
    if (!latestProofDocument) {
      stepLog('Step 5', 'Generate a proof before copying.', 'bad');
      return;
    }
    copy(JSON.stringify(latestProofDocument, null, 2));
    stepLog('Step 5', 'Proof JSON copied to clipboard', 'ok');
  });

  btnProofDownload?.addEventListener('click', () => {
    if (!latestProofDocument) {
      stepLog('Step 5', 'Generate a proof before downloading.', 'bad');
      return;
    }
    const fileName = `${(latestProofDocument.meeting_id || 'meeting').replace(/[^a-z0-9\-]+/gi, '_')}-proof.json`;
    downloadJsonFile(fileName, JSON.stringify(latestProofDocument, null, 2));
    stepLog('Step 5', 'Downloaded proof.json', 'ok');
  });

  btnTryIt?.addEventListener('click', async () => {
    stepLog('Demo', 'Running guided example', 'ok');
    jsonBox.value = JSON.stringify(example, null, 2);
    saltInput.value = example.salt || '';
    selectedProofIndex = 0;
    updateAgendaList();
    resetFeedChecklist();
    setIntegrity(null);
    stepLog('Step 1', 'Loaded demo minutes JSON', 'ok');

    const rootResult = await computeRootFlow({ meetingOverride: example });
    if (!rootResult) {
      return;
    }

    const proofResult = await generateProofFlow(0, { meetingOverride: example });
    if (!proofResult) {
      return;
    }

    const verification = await verifyProofDocumentFlow(proofResult.document, rootResult.root, { addSummary: false });
    if (verification.valid) {
      const agenda = proofResult.document.item?.agenda || 'Agenda item';
      const summary = [
        '‚úÖ Guided demo complete',
        `Merkle root: ${rootResult.root}`,
        `Verified item: ${agenda}`,
        `Meeting: ${proofResult.document.meeting_id} (${proofResult.document.timestamp})`,
        '',
        'Explore each step via the sidebar or paste your own minutes to continue.',
      ].join('\n');
      out.value = summary;
      stepLog('Demo', 'Guided run complete. Output pane updated with summary.', 'ok');
      const step5 = document.getElementById('step-5');
      const step6 = document.getElementById('step-6');
      if (step5) step5.open = true;
      if (step6) step6.open = true;
    }
  });

  btnVerifyProof?.addEventListener('click', async () => {
    let proof;
    try {
      proof = JSON.parse(out.value);
      stepLog('Step 6', 'Parsed proof JSON', 'ok');
    } catch (error) {
      stepLog('Step 6', 'Paste a proof JSON into Output first.', 'bad');
      return;
    }
    latestProofDocument = proof;
    const displayedRoot = rootCode.textContent;
    const expected = displayedRoot && displayedRoot !== '‚Äî' ? displayedRoot : undefined;
    await verifyProofDocumentFlow(proof, expected);
  });

  btnCopyOutput.addEventListener('click', () => copy(out.value));

  // ===== Transcript ‚Üí JSON helpers =====
  function defaultMeetingId() {
    const d = new Date();
    const yyyy = d.getFullYear();
    const mm = String(d.getMonth()+1).padStart(2, '0');
    const dd = String(d.getDate()).padStart(2, '0');
    return `Meeting-${yyyy}-${mm}-${dd}`;
  }

  function ensureMeetingDefaults() {
    if (meetingIdInput && !meetingIdInput.value) {
      meetingIdInput.value = defaultMeetingId();
    }
    if (meetingTsInput && !meetingTsInput.value) {
      meetingTsInput.value = new Date().toISOString();
    }
  }

  function firstSentence(str) {
    const s = String(str || '').replace(/\s+/g, ' ').trim();
    if (!s) return '';
    const m = s.match(/^(.{1,140}?[\.\!\?])\s/);
    return (m ? m[1] : s.slice(0, 80));
  }

  function parseTranscriptToItems(text) {
    const cleaned = String(text || '').replace(/\r\n?/g, '\n').trim();
    if (!cleaned) return [];

    const lines = cleaned.split('\n');

    // Pass 1: marker-based extraction (Agenda:/Topic:/Item:, bullets -,*,‚Ä¢, or numbered 1.)
    const items = [];
    let current = null;
    const flush = () => {
      if (current) {
        const agenda = (current.agenda || '').trim();
        const notes = current.notes.join('\n').trim();
        if (agenda || notes) items.push({ agenda: agenda || firstSentence(notes), notes });
        current = null;
      }
    };

    const agendaRe = /^\s*(?:agenda|topic|item)\s*[:\-]\s*(.+)$/i;
    const bulletRe = /^\s*(?:[\-\*\u2022]|[0-9]{1,2}\.)\s+(.+)$/;

    for (const raw of lines) {
      const line = raw.trimRight();
      if (!line.trim()) { // allow blank lines inside notes; they help the paragraph fallback
        if (current) current.notes.push('');
        continue;
      }
      let m;
      if ((m = line.match(agendaRe))) {
        flush();
        current = { agenda: m[1].trim(), notes: [] };
        continue;
      }
      if ((m = line.match(bulletRe))) {
        flush();
        current = { agenda: m[1].trim(), notes: [] };
        continue;
      }
      // speaker timestamp lines like "[00:10] Alice: ..."
      // treat as note content
      if (!current) {
        current = { agenda: firstSentence(line), notes: [line] };
      } else {
        current.notes.push(line);
      }
    }
    flush();

    if (items.length > 0) {
      return items.slice(0, 100); // guardrail: max 100 items
    }

    // Pass 2: paragraph-based fallback (split by blank lines)
    const paragraphs = cleaned.split(/\n\s*\n+/).map(p => p.trim()).filter(Boolean);
    const paraItems = paragraphs.map(p => ({ agenda: firstSentence(p), notes: p }));
    return paraItems.slice(0, 100);
  }

  function openTranscriptOverlay() {
    ensureMeetingDefaults();
    if (!transcriptOverlay?.classList.contains('open')) {
      transcriptOverlay.classList.add('open');
      document.body.classList.add('modal-open');
      transcriptOverlay.setAttribute('aria-hidden', 'false');
      log('> transcript converter opened');
    }
  }

  function closeTranscriptOverlay() {
    if (transcriptOverlay?.classList.contains('open')) {
      transcriptOverlay.classList.remove('open');
      document.body.classList.remove('modal-open');
      transcriptOverlay.setAttribute('aria-hidden', 'true');
      log('> transcript converter closed');
    }
  }

  btnTranscriptPanel?.addEventListener('click', () => {
    openTranscriptOverlay();
  });

  btnTranscriptClose?.addEventListener('click', () => {
    closeTranscriptOverlay();
  });

  transcriptOverlay?.addEventListener('click', (event) => {
    if (event.target === transcriptOverlay) {
      closeTranscriptOverlay();
    }
  });

  document.addEventListener('keydown', (event) => {
    if (event.key === 'Escape' && transcriptOverlay?.classList.contains('open')) {
      closeTranscriptOverlay();
    }
  });

  transcriptFileInput?.addEventListener('change', async (e) => {
    const f = e.target.files && e.target.files[0];
    if (!f) return;
    const text = await f.text().catch(() => '');
    if (text) {
      transcriptInput.value = text;
      stepLog('Step 0', `Loaded transcript file ${f.name}`, 'ok');
    } else {
      stepLog('Step 0', 'Failed to read transcript file', 'bad');
    }
  });

  btnParseTranscript?.addEventListener('click', () => {
    const text = transcriptInput?.value || '';
    if (!text.trim()) {
      stepLog('Step 0', 'Paste a transcript first', 'bad');
      return;
    }
    ensureMeetingDefaults();
    const items = parseTranscriptToItems(text);
    if (!items.length) {
      stepLog('Step 0', 'Could not detect bullet markers; falling back to paragraphs', 'bad');
    }
    const meeting_id = (meetingIdInput?.value || '').trim() || defaultMeetingId();
    const timestamp = (meetingTsInput?.value || '').trim() || new Date().toISOString();
    const salt = (saltInput?.value || '').trim();
    const meeting = Object.assign({ meeting_id, timestamp, items }, salt ? { salt } : {});
    const json = JSON.stringify(meeting, null, 2);
    if (transcriptJsonOutput) {
      transcriptJsonOutput.value = json;
    }
    lastTranscriptItemsCount = items.length;
    stepLog('Step 0', `Converted transcript into ${items.length || 1} item${items.length === 1 ? '' : 's'} of meeting JSON`, 'ok');
  });

  btnTranscriptCopy?.addEventListener('click', () => {
    if (!transcriptJsonOutput?.value.trim()) {
      stepLog('Step 0', 'Convert transcript before copying', 'bad');
      return;
    }
    copy(transcriptJsonOutput.value);
    stepLog('Step 0', 'Transcript JSON copied to clipboard', 'ok');
  });

  btnTranscriptDownload?.addEventListener('click', () => {
    const payload = transcriptJsonOutput?.value.trim();
    if (!payload) {
      stepLog('Step 0', 'Convert transcript before downloading', 'bad');
      return;
    }
    const baseName = (meetingIdInput?.value || defaultMeetingId()).replace(/[^a-z0-9\-]+/gi, '_') || 'meeting';
    downloadJsonFile(`${baseName}.json`, payload);
    stepLog('Step 0', 'Downloaded meeting JSON', 'ok');
  });

  btnTranscriptFill?.addEventListener('click', async () => {
    const payload = transcriptJsonOutput?.value.trim();
    if (!payload) {
      stepLog('Step 0', 'Convert transcript before sending to Step 1', 'bad');
      return;
    }
    try {
      const parsed = JSON.parse(payload);
      lastTranscriptItemsCount = Array.isArray(parsed.items) ? parsed.items.length : 0;
    } catch (_) {
      lastTranscriptItemsCount = 0;
    }
    jsonBox.value = payload;
    updateAgendaList();
    setIntegrity(null);
    closeTranscriptOverlay();
    selectedProofIndex = 0;
    stepLog('Step 0', 'Meeting JSON filled into Step 1', 'ok');
    if (lastTranscriptItemsCount > 1) {
      await computeRootFlow();
      const proofResult = await generateProofFlow(0);
      if (proofResult) {
        const step5 = document.getElementById('step-5');
        const step6 = document.getElementById('step-6');
        if (step5) step5.open = true;
        if (step6) step6.open = true;
        stepLog('Step 5', 'Auto-generated proof for the first item from transcript', 'ok');
      }
    }
  });

  whyLinks.forEach((link) => {
    link.addEventListener('click', (event) => {
      event.preventDefault();
      out.value = [
        'Why salting matters:',
        '- Without a salt, a guessable phrase might be brute-checked against a hash.',
        '- Adding a random per-meeting salt makes hashes unique and unguessable.',
        '- Include the salt in each item leaf derivation, or in the meeting metadata.',
      ].join('\n');
      stepLog('Step 2', 'Opened salting note', 'ok');
    });
  });

  resetFeedChecklist();
  updateAgendaList();
  setIntegrity(null);
})();
</script>
</body>
</html>
