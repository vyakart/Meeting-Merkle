<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Merkle-Meet ‚Äî Tamper-evident, privacy-preserving minutes</title>
<link rel="icon" href="data:,">
<style>
:root{
  color-scheme: dark;
  --bg: #0b0f14;
  --panel: #0d131a;
  --ink: #e7f8ff;
  --muted: #9fb0bf;
  --accent: #00ffd1;
  --accent-2: #ff00a8;
  --danger: #ff4d6d;
  --ok: #3dfc9a;
  --mono: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace;

  --br: 10px;
  --glow: 0 0 6px rgba(0,255,209,.35), 0 0 24px rgba(255,0,168,.18);
  --line: 1px solid rgba(255,255,255,.06);
  --border-weak: rgba(255,255,255,.12);
  --border-strong: rgba(255,255,255,.24);
  --feed-border: rgba(0,255,209,.18);
  --feed-bg: rgba(9,16,23,.92);
  --feed-text: #c8ffef;
  --input-bg: #0a0f14;
  --button-bg: #0b1218;
  --body-gradient: radial-gradient(1200px 600px at 80% 0%, rgba(255,0,168,.07), transparent 40%),
                   radial-gradient(1000px 700px at 0% 100%, rgba(0,255,209,.07), transparent 40%),
                   var(--bg);
}

[data-theme="light"]{
  color-scheme: light;
  --bg: #f6f8fb;
  --panel: #ffffff;
  --ink: #0b111a;
  --muted: #4c6072;
  --accent: #0066ff;
  --accent-2: #ff3fb4;
  --danger: #d42a4a;
  --ok: #158a4c;
  --glow: 0 0 6px rgba(0,102,255,.25), 0 0 24px rgba(255,63,180,.15);
  --line: 1px solid rgba(8,16,24,.08);
  --border-weak: rgba(11,17,26,.14);
  --border-strong: rgba(11,17,26,.28);
  --feed-border: rgba(0,102,255,.18);
  --feed-bg: rgba(237,242,250,.92);
  --feed-text: #17324a;
  --input-bg: #eef2f8;
  --button-bg: #f5f7fb;
  --body-gradient: radial-gradient(1200px 600px at 80% 0%, rgba(0,102,255,.08), transparent 40%),
                   radial-gradient(1000px 700px at 0% 100%, rgba(255,63,180,.08), transparent 40%),
                   var(--bg);
}
*{box-sizing:border-box}
html,body{height:100%}
body{
  margin:0; background: var(--body-gradient);
  color:var(--ink); font-family: var(--mono); letter-spacing:.2px;
}
.header{
  padding:16px 20px; border-bottom: var(--line); display:flex; align-items:center; gap:12px;
  background: linear-gradient(180deg, rgba(255,255,255,.03), rgba(255,255,255,0));
}
.brand{
  font-weight:700; font-size:18px; letter-spacing:.6px;
}
.tagline{color:var(--muted); font-size:12px}

.badge{
  margin-left:8px; padding:4px 10px; border:1px solid var(--border-weak);
  border-radius:999px; color:var(--muted); display:flex; align-items:center; gap:8px;
}
.grid{
  display:grid; grid-template-columns: 320px 1fr; gap:16px; padding:16px; height:calc(100% - 58px);
}
.sidebar{
  background: var(--panel); border: var(--line); border-radius: var(--br); padding:12px; overflow:auto;
}
.step{
  border-radius:8px;
  border:1px dashed rgba(255,255,255,.08);
  margin-bottom:10px;
  background:rgba(255,255,255,.02);
}
.step summary{
  cursor:pointer;
  list-style:none;
  padding:8px 10px;
  font-size:13px;
  color:var(--accent);
  font-weight:600;
  display:flex;
  align-items:center;
  justify-content:space-between;
  gap:12px;
}
.step summary::-webkit-details-marker{display:none;}
.step .step-body{padding:0 10px 10px 10px;}
.step .step-body p{margin:0 0 8px 0; color:var(--muted); font-size:12px; line-height:1.4}
.step .actions{display:flex; flex-wrap:wrap; gap:6px}
.step-help{
  border:none;
  background:rgba(255,255,255,.08);
  color:var(--muted);
  border-radius:50%;
  width:20px;
  height:20px;
  font-size:12px;
  display:inline-flex;
  align-items:center;
  justify-content:center;
  cursor:pointer;
}
.step-help:focus-visible{outline:2px solid var(--accent);}
.step-helptext{
  display:none;
  font-size:12px;
  color:var(--muted);
  border-left:2px solid rgba(255,255,255,.08);
  padding-left:8px;
  margin-bottom:8px;
}
.step-helptext.visible{display:block;}
button,.btn{
  background:var(--button-bg); color:var(--ink); border:1px solid var(--border-weak);
  padding:8px 10px; border-radius:8px; cursor:pointer; font-family:var(--mono);
}
button:not(.cta-button):hover{border-color:var(--border-strong)}
button.primary{
  border-color: var(--accent); box-shadow: var(--glow);
}
button.ghost{background:transparent}

.cta-button{
  position:relative;
  display:inline-flex;
  flex-direction:column;
  align-items:flex-start;
  gap:2px;
  padding:12px 16px;
  border-radius:14px;
  background:linear-gradient(135deg, rgba(0,255,209,.18), rgba(255,0,168,.16));
  border:1px solid rgba(255,255,255,.18);
  color:var(--ink);
  box-shadow:0 14px 28px rgba(0,0,0,.22);
  transition:transform .15s ease, box-shadow .15s ease, border-color .15s ease;
}
.cta-button:hover{
  transform:translateY(-1px);
  border-color:rgba(0,255,209,.4);
  box-shadow:0 18px 32px rgba(0,0,0,.28);
}
.cta-button:focus-visible{
  outline:2px solid var(--accent);
  outline-offset:2px;
}
.cta-label{font-size:13px; font-weight:700; letter-spacing:.3px;}
.cta-sub{font-size:11px; color:var(--muted);}
#theme-toggle{
  margin-left:auto;
  width:40px;
  height:40px;
  display:flex;
  align-items:center;
  justify-content:center;
  border-radius:12px;
  padding:0;
}
#theme-toggle svg{width:20px;height:20px;display:block;stroke:currentColor;stroke-width:1.5;}
#theme-toggle circle{stroke:currentColor;fill:none;}
#theme-toggle line{stroke:currentColor;stroke-linecap:round;}
#theme-toggle path{stroke:currentColor;stroke-linecap:round;fill:currentColor;stroke-width:1.2;}
input,textarea{
  width:100%; background:var(--input-bg); color:var(--ink); border:1px solid var(--border-weak);
  border-radius:8px; padding:10px; font-family:var(--mono); font-size:12px;
}
label{font-size:12px; color:var(--muted)}
.main{
  display:grid; grid-template-rows: auto 1fr auto; gap:12px; min-height:0;
}
.panel{
  background: var(--panel); border: var(--line); border-radius: var(--br); padding:12px; min-height:0;
}
.hero{
  display:flex; align-items:flex-start; justify-content:space-between; gap:12px;
  position:sticky;
  top:-1px;
  z-index:10;
  background:var(--panel);
  border-bottom:1px solid rgba(255,255,255,.04);
  padding-bottom:12px;
}
.hero .left{display:flex; flex-direction:column; gap:4px}
.hero .title{font-size:16px; font-weight:700}
.hero .subtitle{font-size:12px; color:var(--muted)}
.hero .actions{display:flex; flex-wrap:wrap; gap:8px; align-items:center;}
.kv{
  display:grid; grid-template-columns: 1fr 1fr; gap:12px;
}
.kv .box{display:flex; flex-direction:column; gap:6px}
.feed{
  background:var(--feed-bg); border:1px solid var(--feed-border); border-radius:8px;
  padding:10px; font-size:12px; color:var(--feed-text); height:220px; overflow:auto;
}
.feed .line{white-space:pre-wrap; margin:0 0 4px 0}
.feed .ok{color:var(--ok)}
.feed .bad{color:var(--danger)}
.mono{font-family:var(--mono)}
.row{display:flex; gap:8px; align-items:center}
.small{font-size:12px}
.code{background:#081018; border:1px solid rgba(255,255,255,.12); border-radius:8px; padding:8px; font-size:12px}
.status{
  display:flex;
  align-items:flex-start;
  gap:10px;
  color:var(--muted);
  font-size:12px;
}
.root-readout{margin:0; display:flex; align-items:center; gap:6px; font-size:12px; color:var(--muted); font-family:var(--mono);}
.dot{width:8px;height:8px;border-radius:50%;background:#8b93a0;border:1px solid #444}
.dot.ok{background:var(--ok); box-shadow:0 0 10px rgba(61,252,154,.6)}
.dot.bad{background:var(--danger); box-shadow:0 0 10px rgba(255,77,109,.6)}
.status-info{display:flex; flex-direction:column; gap:4px;}
.status-message{color:var(--muted); font-family:var(--mono); font-size:11px; letter-spacing:.3px;}
.status-message.ok{color:var(--ok);}
.status-message.error{color:var(--danger);}
.status-message:empty{display:none;}
.footer{
  display:flex; justify-content:space-between; align-items:center; gap:8px; color:var(--muted); font-size:12px
}
a.link{color:var(--accent)}
hr.div{border:0;border-top:1px solid rgba(255,255,255,.08);margin:8px 0}
.scanlines{
  position:fixed; inset:0; pointer-events:none;
  background: repeating-linear-gradient(0deg, rgba(255,255,255,.02), rgba(255,255,255,.02) 1px, transparent 1px, transparent 3px);
  mix-blend-mode:overlay; opacity:.25;
}
body.modal-open{overflow:hidden;}

.transcript-overlay{
  position:fixed;
  inset:0;
  background:rgba(6,12,18,0.78);
  backdrop-filter:blur(10px);
  display:none;
  align-items:center;
  justify-content:center;
  padding:24px;
  z-index:1000;
}

.transcript-overlay.open{display:flex;}

.transcript-dialog{
  width:min(960px,100%);
  max-height:90vh;
  overflow:auto;
  background:var(--panel);
  border:var(--line);
  border-radius:var(--br);
  padding:20px;
  box-shadow:0 40px 80px rgba(0,0,0,0.45);
  display:flex;
  flex-direction:column;
  gap:16px;
}

.transcript-dialog header{
  display:flex;
  align-items:center;
  justify-content:space-between;
  gap:12px;
}

.transcript-dialog h2{
  margin:0;
  font-size:16px;
  letter-spacing:.4px;
}

.transcript-grid{
  display:grid;
  grid-template-columns:repeat(2,minmax(0,1fr));
  gap:16px;
}

@media (max-width: 960px){
  .transcript-grid{grid-template-columns:1fr;}
}

.transcript-section{
  display:flex;
  flex-direction:column;
  gap:8px;
}

.transcript-actions{
  display:flex;
  flex-wrap:wrap;
  gap:8px;
}

.transcript-note{
  font-size:12px;
  color:var(--muted);
}

.example-overlay{
  position:fixed;
  inset:0;
  background:rgba(6,12,18,0.78);
  backdrop-filter:blur(10px);
  display:none;
  align-items:center;
  justify-content:center;
  padding:24px;
  z-index:900;
}

.example-overlay.open{display:flex;}

.example-dialog{
  width:min(880px,100%);
  max-height:88vh;
  overflow:auto;
  background:var(--panel);
  border:var(--line);
  border-radius:var(--br);
  padding:20px;
  box-shadow:0 32px 64px rgba(0,0,0,0.45);
  display:flex;
  flex-direction:column;
  gap:16px;
}

.example-dialog header{display:flex;align-items:center;justify-content:space-between;gap:12px;}
.example-dialog h2{margin:0;font-size:16px;letter-spacing:.4px;}
.example-intro{margin:0;color:var(--muted);font-size:12px;line-height:1.5;}
.example-grid{display:grid;grid-template-columns:repeat(2,minmax(0,1fr));gap:12px;}
.example-card{border:1px solid rgba(255,255,255,.08);border-radius:12px;padding:14px;background:rgba(255,255,255,.03);display:flex;flex-direction:column;gap:10px;}
.example-card h3{margin:0;font-size:14px;}
.example-card p{margin:0;color:var(--muted);font-size:12px;line-height:1.5;}
.example-card footer{display:flex;gap:8px;flex-wrap:wrap;margin-top:auto;}
.example-card button{flex:1 1 auto;}

@media (max-width: 720px){
  .example-grid{grid-template-columns:1fr;}
}

.salt-row{display:flex; align-items:center; gap:6px; flex-wrap:wrap;}
.salt-tip{font-size:12px; color:var(--muted); display:flex; align-items:center; gap:6px;}
.salt-tip button{padding:4px 10px; font-size:11px; border-radius:999px;}
.tooltip{position:relative; display:inline-flex; align-items:center;}
.tooltip:hover .tooltip-content,
.tooltip:focus-within .tooltip-content{opacity:1; transform:translateY(0); pointer-events:auto;}
.tooltip-icon{
  width:16px;
  height:16px;
  border-radius:50%;
  background:rgba(255,255,255,.08);
  display:inline-flex;
  align-items:center;
  justify-content:center;
  font-size:11px;
  cursor:pointer;
}
.tooltip-content{
  position:absolute;
  bottom:calc(100% + 6px);
  left:50%;
  transform:translate(-50%, 6px);
  background:var(--panel);
  border:1px solid var(--border-weak);
  border-radius:8px;
  padding:8px 10px;
  font-size:11px;
  color:var(--muted);
  width:220px;
  box-shadow:0 12px 32px rgba(0,0,0,.25);
  opacity:0;
  pointer-events:none;
  transition:opacity .15s ease, transform .15s ease;
  z-index:20;
}
.tooltip-content p{margin:0;}
.tooltip-content a{display:inline-block;margin-top:6px;}

.items-overview{
  border:1px solid var(--border-weak);
  border-radius:10px;
  padding:8px;
  max-height:240px;
  overflow:auto;
  background:rgba(255,255,255,.02);
}
.items-overview label{
  display:grid;
  grid-template-columns:16px 1fr;
  gap:10px;
  align-items:flex-start;
  font-size:12px;
  color:var(--ink);
  padding:8px 6px;
  border-radius:8px;
  cursor:pointer;
  line-height:1.45;
}
.items-overview label:hover{background:rgba(255,255,255,.04);}
.items-overview input[type="radio"]{margin-top:3px;}
.items-overview .item-body{display:flex; flex-direction:column; gap:2px;}
.items-overview .item-title{font-weight:600; display:block;}
.items-overview .item-notes{color:var(--muted); font-size:11px; display:block; line-height:1.4;}

.proof-actions{display:flex; flex-wrap:wrap; gap:6px; margin-top:6px;}
.feed ul{margin:0;padding-left:18px;}

.bls-section{display:flex;flex-direction:column;gap:6px;margin-bottom:10px;}
.bls-row{display:flex;flex-wrap:wrap;gap:8px;align-items:center;}
.bls-mode label{display:flex;align-items:center;gap:6px;font-size:12px;color:var(--muted);}
.bls-mode input{margin:0;}
.bls-note{display:flex;align-items:center;gap:6px;}
.bls-note .tooltip{margin-left:auto;}
.bls-table-wrap{border:1px solid var(--border-weak);border-radius:8px;overflow:hidden;background:rgba(255,255,255,.02);}
.bls-table{width:100%;border-collapse:collapse;font-size:11px;}
.bls-table th,.bls-table td{border-bottom:1px solid var(--border-weak);padding:6px;vertical-align:top;word-break:break-all;}
.bls-table:not(.has-pop) th:nth-child(2),
.bls-table:not(.has-pop) td:nth-child(2){display:none;}
.bls-table tbody tr:last-child td{border-bottom:none;}
.bls-actions-col{width:70px;}
.bls-table button{font-size:11px;padding:4px 8px;}
.bls-add-row input{flex:1 1 140px;}
#bls-attestation{min-height:140px;}
#bls-signature,#bls-aggregate-sig{min-height:72px;}
.bls-verify-status{font-size:11px;color:var(--muted);margin-top:4px;}
.bls-verify-status.ok{color:var(--ok);}
.bls-verify-status.bad{color:var(--danger);}

.hero-sticky-spacer{height:0;}
body.modal-open{overflow:hidden;}

.transcript-overlay{
  position:fixed;
  inset:0;
  background:rgba(6,12,18,0.78);
  backdrop-filter:blur(10px);
  display:none;
  align-items:center;
  justify-content:center;
  padding:24px;
  z-index:1000;
}

.transcript-overlay.open{display:flex;}

.transcript-dialog{
  width:min(960px,100%);
  max-height:90vh;
  overflow:auto;
  background:var(--panel);
  border:var(--line);
  border-radius:var(--br);
  padding:20px;
  box-shadow:0 40px 80px rgba(0,0,0,0.45);
  display:flex;
  flex-direction:column;
  gap:16px;
}

.transcript-dialog header{
  display:flex;
  align-items:center;
  justify-content:space-between;
  gap:12px;
}

.transcript-note{
  font-size:12px;
  color:var(--muted);
}
@media (max-width: 900px){
  .grid{grid-template-columns:1fr}
  .sidebar{order:2;}
  .main{order:1;}
  .kv{grid-template-columns:1fr}
  .hero{top:-1px;}
  .step{border:1px solid rgba(255,255,255,.12);}
}
</style>
</head>
<body>
  <div class="header" role="banner">
    <div class="brand">MERKLE-MEET</div>
    <div class="tagline">Tamper-evident, privacy-preserving minutes</div>
    <button class="ghost" id="theme-toggle" type="button" aria-label="Toggle theme">Light Theme</button>
    <div class="badge" aria-live="polite">
      <span class="dot" id="integrity-dot" title="Integrity badge"></span> integrity
    </div>
  </div>

  <div class="grid" role="main">
    <aside class="sidebar" aria-label="Steps">
      <details class="step" id="step-0-transcript" open>
        <summary>
          <span>Step 0 ‚Äî From Transcript (optional)</span>
          <button class="step-help" type="button" data-help="help-step-0" aria-label="Explain transcript conversion">?</button>
        </summary>
        <div class="step-body">
          <div class="step-helptext" id="help-step-0">Use a raw transcript to auto-build meeting minutes before hashing. The parser extracts agenda lines and notes into structured JSON.</div>
          <p>Drop in a raw transcript, convert to meeting JSON, then copy, download, or fill Step 1 automatically.</p>
          <div class="actions">
            <button class="ghost" id="btn-transcript-panel" type="button">Open Transcript Converter</button>
          </div>
        </div>
      </details>

      <details class="step" id="step-1" open>
        <summary>
          <span>Step 1 ‚Äî Load Minutes</span>
          <button class="step-help" type="button" data-help="help-step-1" aria-label="Explain minutes JSON">?</button>
        </summary>
        <div class="step-body">
          <div class="step-helptext" id="help-step-1">Minutes JSON is the canonical record we hash. Each agenda item becomes a Merkle leaf in the order it appears. Review or edit it before computing the root.</div>
          <p>Paste your minutes JSON. You can load an example to explore.</p>
          <div class="actions">
            <button class="ghost" id="btn-example">Load Example</button>
            <button class="ghost" id="btn-clear">Clear</button>
          </div>
        </div>
      </details>

      <details class="step" id="step-2" open>
        <summary>
          <span>Step 2 ‚Äî Compute Root</span>
          <button class="step-help" type="button" data-help="help-step-2" aria-label="Explain Merkle root">?</button>
        </summary>
        <div class="step-body">
          <div class="step-helptext" id="help-step-2">A Merkle root is a single fingerprint for the entire meeting. Any change to agenda or notes alters the root, making tampering evident.</div>
          <p>Normalize ‚Üí hash items (SHA-256) ‚Üí build Merkle tree.</p>
          <div class="actions">
            <button class="primary" id="btn-root">Compute Root</button>
            <button id="btn-copy-root">Copy Root</button>
          </div>
        </div>
      </details>

      <details class="step" id="step-3" open>
        <summary>
          <span>Step 3 ‚Äî Co-sign Root (BLS)</span>
          <button class="step-help" type="button" data-help="help-step-3" aria-label="Explain BLS co-signing">?</button>
        </summary>
        <div class="step-body">
          <div class="step-helptext" id="help-step-3">BLS signatures let multiple attendees co-sign the same Merkle root. Augmentation defends against rogue keys; proof-of-possession enables fast aggregate verification once each key is registered.</div>
          <p>Select an aggregation mode, derive your key pair, then sign and collect signatures for this attestation.</p>
          <div class="bls-section" role="group" aria-labelledby="bls-mode-label">
            <span id="bls-mode-label" class="small">Aggregation mode</span>
            <div class="bls-row bls-mode">
              <label>
                <input type="radio" name="bls-mode" value="aug" checked />
                Augmentation (default)
              </label>
              <label>
                <input type="radio" name="bls-mode" value="pop" />
                Proof-of-possession (fast verify)
              </label>
            </div>
          </div>
          <div class="bls-section">
            <label for="bls-sk">Your BLS Secret Key (hex, 32 bytes)</label>
            <div class="bls-row">
              <input id="bls-sk" autocomplete="off" placeholder="Paste or generate a 32-byte hex secret" />
              <button id="btn-bls-generate-sk" type="button">Generate demo key</button>
            </div>
            <div class="small bls-note" role="note">Demo-only keygen: bring your real secret key for production co-signing.</div>
          </div>
          <div class="bls-section">
            <label for="bls-pk">Your BLS Public Key (hex)</label>
            <input id="bls-pk" placeholder="Auto-derived once the secret key is set" />
          </div>
          <div class="bls-section" id="bls-pop-section" hidden>
            <label for="bls-pop">Your PoP (hex)</label>
            <div class="bls-row">
              <input id="bls-pop" placeholder="Proof-of-possession for your public key" />
              <button id="btn-bls-generate-pop" type="button">Generate PoP</button>
            </div>
          </div>
          <div class="bls-section">
            <label for="bls-attestation">Attestation preview</label>
            <textarea id="bls-attestation" rows="6" readonly placeholder="Compute a Merkle root to populate the attestation JSON."></textarea>
          </div>
          <div class="bls-section">
            <div class="bls-row">
              <button id="btn-bls-sign" class="primary" type="button">Sign attestation</button>
              <button id="btn-bls-add-self" type="button">Add my signature to list</button>
            </div>
            <textarea id="bls-signature" rows="3" readonly placeholder="Signature (hex) will appear here after signing."></textarea>
          </div>
          <div class="bls-section">
            <div class="bls-row" style="justify-content:space-between;">
              <span class="small">Collected signatures</span>
              <button id="btn-bls-clear-signers" class="ghost small" type="button">Clear list</button>
            </div>
            <div class="bls-table-wrap">
              <table class="bls-table" id="bls-signers-table" aria-live="polite">
                <thead>
                  <tr>
                    <th scope="col">Public key</th>
                    <th scope="col" id="bls-pop-col">PoP</th>
                    <th scope="col">Signature</th>
                    <th scope="col" class="bls-actions-col">Actions</th>
                  </tr>
                </thead>
                <tbody id="bls-signers-body">
                  <tr data-empty>
                    <td colspan="4">No signatures collected yet.</td>
                  </tr>
                </tbody>
              </table>
            </div>
            <div class="bls-row bls-add-row">
              <input id="bls-add-pk" placeholder="Public key (hex)" />
              <input id="bls-add-pop" placeholder="PoP (hex)" />
              <input id="bls-add-sig" placeholder="Signature (hex)" />
              <button id="btn-bls-add-row" type="button">Add row</button>
            </div>
          </div>
          <div class="bls-section">
            <div class="bls-row">
              <button id="btn-bls-aggregate" type="button">Aggregate &amp; Verify</button>
            </div>
            <textarea id="bls-aggregate-sig" rows="3" readonly placeholder="Aggregate signature (hex) will appear here after verification."></textarea>
            <div class="bls-verify-status" id="bls-aggregate-status" aria-live="polite"></div>
            <div class="bls-row">
              <button id="btn-bls-copy-payload" type="button">Copy attestation+signatures JSON</button>
              <button id="btn-bls-copy-aggregate" type="button">Copy aggregate signature</button>
            </div>
            <div class="bls-note small">
              <span aria-hidden="true">üîí</span>
              <span>BLS aggregation lets multiple people co-sign the same root; any tampering flips verification.</span>
              <span class="tooltip" role="presentation">
                <button class="tooltip-icon" type="button" aria-label="BLS draft reference">i</button>
                <span class="tooltip-content"><p>Built on draft-irtf-cfrg-bls-signature. Aggregate signatures stay 96 bytes even as collaborators grow.</p><a class="link" href="https://datatracker.ietf.org/doc/draft-irtf-cfrg-bls-signature/" target="_blank" rel="noopener">Read the draft ‚Üí</a></span>
              </span>
            </div>
          </div>
        </div>
      </details>

      <details class="step" id="step-4" open>
        <summary>
          <span>Step 4 ‚Äî Publish &amp; Share</span>
          <button class="step-help" type="button" data-help="help-step-4" aria-label="Explain publishing the root">?</button>
        </summary>
        <div class="step-body">
          <div class="step-helptext" id="help-step-4">Share the Merkle root (and proof, if needed) with your team. Anyone can recompute the root locally and confirm it matches.</div>
          <p>Post the root where others can see (e.g. Slack).</p>
          <div class="actions">
            <button id="btn-slack">Compose Slack message</button>
            <button id="btn-slack-copy" type="button">Copy Slack message</button>
          </div>
        </div>
      </details>

      <details class="step" id="step-5" open>
        <summary>
          <span>Step 5 ‚Äî Verify Record</span>
          <button class="step-help" type="button" data-help="help-step-5" aria-label="Explain verification">?</button>
        </summary>
        <div class="step-body">
          <div class="step-helptext" id="help-step-5">Verification recomputes the fingerprint from your minutes and checks it against an expected root. Matching roots confirm no changes were made.</div>
          <p>Recompute from JSON and compare to an expected root.</p>
          <div class="actions row">
            <input id="expected-root" placeholder="Expected root (hex)" aria-label="Expected root" />
            <button id="btn-verify-root">Verify Against Root</button>
          </div>
        </div>
      </details>

      <details class="step" id="step-6" open>
        <summary>
          <span>Step 6 ‚Äî Generate Proof</span>
          <button class="step-help" type="button" data-help="help-step-6" aria-label="Explain membership proofs">?</button>
        </summary>
        <div class="step-body">
          <div class="step-helptext" id="help-step-6">A membership proof lets you show one agenda item was part of the meeting without revealing the rest of the notes.</div>
          <p>Select an agenda item (radio list beside the minutes) to generate its inclusion proof.</p>
          <div class="actions row" style="margin-top:6px">
            <input id="proof-index" placeholder="Item index (0-based)" aria-label="Item index (optional)" />
            <button id="btn-proof">Create Proof</button>
          </div>
          <div class="proof-actions">
            <button id="btn-proof-copy" type="button">Copy proof JSON</button>
            <button id="btn-proof-download" type="button">Download proof.json</button>
          </div>
        </div>
      </details>

      <details class="step" id="step-7" open>
        <summary>
          <span>Step 7 ‚Äî Verify Proof</span>
          <button class="step-help" type="button" data-help="help-step-7" aria-label="Explain proof verification">?</button>
        </summary>
        <div class="step-body">
          <div class="step-helptext" id="help-step-7">Proof verification replays the Merkle path to ensure the proof matches the root you trust. If any hash or ordering is wrong, verification fails.</div>
          <p>Check a membership proof against the root.</p>
          <div class="actions">
            <button id="btn-verify-proof">Verify Proof</button>
            <button id="btn-copy-output">Copy Output</button>
          </div>
        </div>
      </details>
    </aside>

    <section class="main">
      <div class="panel hero" aria-live="polite">
        <div class="left">
          <div class="title">Trust the minutes. Not the note-taker.</div>
          <div class="subtitle">All verification is local. No servers. No secrets leaked.</div>
          <div class="actions">
            <button class="cta-button" id="btn-try-it" type="button">
              <span class="cta-label">Walk through an example</span>
              <span class="cta-sub">Load curated minutes &rarr;</span>
            </button>
          </div>
        </div>
        <div class="status">
          <span class="dot" id="integrity-dot" aria-label="Integrity status: idle"></span>
          <div class="status-info">
            <div class="root-readout"><span>Root:</span> <code id="root" class="mono">‚Äî</code></div>
            <div class="status-message" id="integrity-label" aria-live="polite"></div>
          </div>
        </div>
      </div>

      <div class="panel kv">
        <div class="box">
          <label for="json">Minutes JSON</label>
          <textarea id="json" rows="12" placeholder='Paste your minutes JSON here...'></textarea>
          <div class="salt-row small">
            <div class="row small" style="gap:6px;align-items:center;">
              <label for="salt" style="min-width:80px;margin:0;">Salt (opt.)</label>
              <div class="tooltip">
                <button type="button" class="tooltip-icon" aria-describedby="salt-tooltip">i</button>
                <div class="tooltip-content" role="tooltip" id="salt-tooltip">
                  <p>Salts add randomness so identical minutes produce different hashes.</p>
                  <a href="#" class="why-link">Learn more</a>
                </div>
              </div>
            </div>
            <input id="salt" placeholder="random-16-bytes" aria-label="Salt" />
            <button id="btn-salt-generate" type="button">Generate random salt</button>
          </div>
          <div class="items-overview" id="items-overview" role="radiogroup" aria-live="polite" aria-label="Agenda items"></div>
        </div>

        <div class="box">
          <label>Terminal Feed</label>
          <div class="feed" id="feed" aria-live="polite" aria-atomic="false">
            <ul class="small" id="empty-line">
              <li>1. Load or convert minutes JSON.</li>
              <li>2. Compute the Merkle root (salt optional).</li>
              <li>3. Share or verify proofs as needed.</li>
            </ul>
          </div>
          <hr class="div" />
          <div class="box">
            <label for="output">Output</label>
            <textarea id="output" rows="6" class="mono" placeholder="Proofs, verification results, and composer text appear here."></textarea>
          </div>
        </div>
      </div>

      <div class="panel footer">
        <div>SHA-256 ‚Ä¢ Odd-leaf duplication ‚Ä¢ Canonical JSON ‚Ä¢ Local-only</div>
        <div><a class="link why-link" href="#" id="why-link">Why salting matters</a></div>
      </div>
    </section>
  </div>

  <div class="scanlines" aria-hidden="true"></div>

  <div class="transcript-overlay" id="transcript-overlay" aria-hidden="true" role="dialog" aria-modal="true">
    <div class="transcript-dialog" id="transcript-dialog">
      <header>
        <h2>Transcript ‚Üí Meeting JSON</h2>
        <button id="btn-transcript-close" class="ghost" type="button" aria-label="Close transcript converter">√ó</button>
      </header>
      <div class="transcript-grid">
        <div class="transcript-section">
          <label class="small" for="meeting-id">Meeting metadata</label>
          <div class="row small" style="gap:8px;flex-wrap:wrap">
            <input id="meeting-id" placeholder="meeting_id" style="flex:1 1 200px" />
            <input id="meeting-timestamp" placeholder="timestamp (ISO-8601)" style="flex:1 1 220px" />
          </div>
          <input type="file" id="transcript-file" accept=".txt,.md,.vtt,.srt" class="small" />
          <label class="small" for="transcript">Transcript (paste raw text)</label>
          <textarea id="transcript" rows="14" placeholder="Paste the meeting transcript here‚Ä¶ Bullets (-, *, 1.) or lines starting with 'Agenda:'/'Topic:' become items. Blank lines split paragraphs."></textarea>
        </div>
        <div class="transcript-section">
          <label class="small" for="transcript-json">Generated meeting JSON</label>
          <textarea id="transcript-json" rows="14" class="mono" placeholder="Converted JSON will appear here after parsing."></textarea>
        </div>
      </div>
      <div class="transcript-actions">
        <button id="btn-parse-transcript" class="primary" type="button">Convert Transcript</button>
        <button id="btn-transcript-copy" type="button">Copy JSON</button>
        <button id="btn-transcript-download" type="button">Download JSON</button>
        <button id="btn-transcript-fill" type="button">Send to Step 1</button>
      </div>
      <div class="transcript-note">
        Recognizes bullets, numbered lists, and ‚ÄúAgenda:‚Äù/‚ÄúTopic:‚Äù headers. You can tweak the JSON before copying or filling Step 1.
      </div>
    </div>
  </div>

  <div class="example-overlay" id="example-overlay" aria-hidden="true">
    <div class="example-dialog" role="dialog" aria-modal="true" aria-labelledby="examples-title">
      <header>
        <h2 id="examples-title">Choose a sample meeting</h2>
        <button id="btn-example-close" class="ghost" type="button" aria-label="Close examples">√ó</button>
      </header>
      <p class="example-intro">Pick one of the curated Summer of Protocols sessions to populate Step 1, then continue through the flow yourself.</p>
      <div class="example-grid" id="example-grid" role="list"></div>
    </div>
  </div>

<script>
(() => {
  const encoder = new TextEncoder();

  const $ = (sel) => document.querySelector(sel);
  const feed = document.getElementById('feed');
  const rootCode = document.getElementById('root');
  const out = document.getElementById('output');
  const jsonBox = document.getElementById('json');
  const dot = document.getElementById('integrity-dot');
  const integrityLabel = document.getElementById('integrity-label');
  const itemsOverview = document.getElementById('items-overview');
  const btnTryIt = document.getElementById('btn-try-it');
  const btnSaltGenerate = document.getElementById('btn-salt-generate');
  const btnSlackCopy = document.getElementById('btn-slack-copy');
  const btnProofCopy = document.getElementById('btn-proof-copy');
  const btnProofDownload = document.getElementById('btn-proof-download');
  const blsModeRadios = document.querySelectorAll('input[name="bls-mode"]');
  const blsSkInput = document.getElementById('bls-sk');
  const blsPkInput = document.getElementById('bls-pk');
  const blsPopSection = document.getElementById('bls-pop-section');
  const blsPopInput = document.getElementById('bls-pop');
  const blsAttestationTextarea = document.getElementById('bls-attestation');
  const blsSignatureTextarea = document.getElementById('bls-signature');
  const blsAggregateTextarea = document.getElementById('bls-aggregate-sig');
  const blsAggregateStatus = document.getElementById('bls-aggregate-status');
  const blsSignersTable = document.getElementById('bls-signers-table');
  const blsSignersBody = document.getElementById('bls-signers-body');
  const blsPopHeader = document.getElementById('bls-pop-col');
  const blsAddPkInput = document.getElementById('bls-add-pk');
  const blsAddPopInput = document.getElementById('bls-add-pop');
  const blsAddSigInput = document.getElementById('bls-add-sig');
  const btnBlsGenerateSk = document.getElementById('btn-bls-generate-sk');
  const btnBlsGeneratePop = document.getElementById('btn-bls-generate-pop');
  const btnBlsSign = document.getElementById('btn-bls-sign');
  const btnBlsAddSelf = document.getElementById('btn-bls-add-self');
  const btnBlsAddRow = document.getElementById('btn-bls-add-row');
  const btnBlsAggregate = document.getElementById('btn-bls-aggregate');
  const btnBlsCopyPayload = document.getElementById('btn-bls-copy-payload');
  const btnBlsCopyAggregate = document.getElementById('btn-bls-copy-aggregate');
  const btnBlsClearSigners = document.getElementById('btn-bls-clear-signers');
  const exampleOverlay = document.getElementById('example-overlay');
  const exampleGrid = document.getElementById('example-grid');
  const btnExampleClose = document.getElementById('btn-example-close');

  function isPlainObject(value) {
    return value !== null && typeof value === 'object' && !Array.isArray(value);
  }

  function canonicalizeString(value, field) {
    if (typeof value !== 'string') {
      throw new Error(`${field} must be a string`);
    }
    return value.replace(/\r\n?/g, '\n');
  }

  function canonicalizeOptionalString(value, field) {
    if (value === undefined) {
      return undefined;
    }
    return canonicalizeString(value, field);
  }

  function validateTimestamp(value, field) {
    if (Number.isNaN(Date.parse(value))) {
      throw new Error(`${field} must be an ISO-8601 timestamp`);
    }
    return value;
  }

  function normalizeMeetingObject(raw, saltOverride) {
    if (!isPlainObject(raw)) {
      throw new Error('Minutes JSON must be an object.');
    }
    const meeting_id = canonicalizeString(raw.meeting_id, 'meeting_id');
    const timestamp = validateTimestamp(canonicalizeString(raw.timestamp, 'timestamp'), 'timestamp');
    const salt = saltOverride !== undefined && saltOverride !== ''
      ? canonicalizeString(saltOverride, 'salt')
      : canonicalizeOptionalString(raw.salt, 'salt');
    const itemsValue = raw.items;
    if (!Array.isArray(itemsValue)) {
      throw new Error('Items must be an array of {agenda, notes}.');
    }
    if (itemsValue.length === 0) {
      throw new Error('No agenda items found. Add at least one {agenda, notes} pair.');
    }
    const items = itemsValue.map((entry, index) => {
      if (!isPlainObject(entry)) {
        throw new Error(`items[${index}] must be an object`);
      }
      return {
        agenda: canonicalizeString(entry.agenda, `items[${index}].agenda`),
        notes: canonicalizeString(entry.notes, `items[${index}].notes`),
      };
    });
    return { meeting_id, timestamp, salt, items };
  }

  function bytesToHex(bytes) {
    return Array.from(bytes, (byte) => byte.toString(16).padStart(2, '0')).join('');
  }

  function hexToBytes(hex) {
    if (typeof hex !== 'string' || hex.length % 2 !== 0 || !/^[0-9a-f]*$/i.test(hex)) {
      throw new Error('Hex value must be an even-length hexadecimal string.');
    }
    const array = new Uint8Array(hex.length / 2);
    for (let i = 0; i < hex.length; i += 2) {
      array[i / 2] = Number.parseInt(hex.slice(i, i + 2), 16);
    }
    return array;
  }

  async function hashBytes(bytes) {
    const buffer = await crypto.subtle.digest('SHA-256', bytes);
    return new Uint8Array(buffer);
  }

  async function hashUtf8(text) {
    return hashBytes(encoder.encode(text));
  }

  const BLS_CONTEXT = 'merkle-meet/v1';
  const BLS_PREFIX = 'MM-ATTESTATION-V1\n';
  const BLS_MODES = { AUG: 'aug', POP: 'pop' };

  let blsInitPromise = null;
  let blsProvider = null;
  let blsProviderName = null;

  function normalizeHex(hex) {
    return (hex || '').trim().toLowerCase();
  }

  function ensureUint8Array(value, label) {
    if (value instanceof Uint8Array) {
      return value;
    }
    if (ArrayBuffer.isView(value)) {
      return new Uint8Array(value.buffer.slice(value.byteOffset, value.byteOffset + value.byteLength));
    }
    if (value instanceof ArrayBuffer) {
      return new Uint8Array(value);
    }
    if (Array.isArray(value)) {
      return Uint8Array.from(value);
    }
    throw new Error(`${label} must be bytes`);
  }

  function assertBytesLength(bytes, expected, label) {
    if (bytes.length !== expected) {
      throw new Error(`${label} must be ${expected} bytes`);
    }
  }

  async function loadChainsafeBls() {
    const mod = await import('https://esm.sh/@chainsafe/bls@8.2.0/herumi');
    const bls = mod?.default ?? mod;
    if (!bls) {
      return null;
    }
    if (typeof bls.init === 'function') {
      await bls.init(bls.BLS12_381);
    } else if (typeof bls.initBLS === 'function') {
      await bls.initBLS();
    }
    return {
      name: 'chainsafe',
      getPublicKey: (sk) => bls.getPublicKey(sk),
      sign: (sk, msg) => bls.sign(msg, sk),
      verify: (pk, msg, sig) => bls.verify(sig, msg, pk),
      aggregateSignatures: (sigs) => bls.aggregateSignatures(sigs),
      aggregateVerify: (pks, msgs, aggSig) => bls.aggregateVerify(pks, msgs, aggSig),
      fastAggregateVerify: (pks, msg, aggSig) => bls.fastAggregateVerify(pks, msg, aggSig),
      popProve: typeof bls.popProve === 'function' ? (sk) => bls.popProve(sk) : null,
      popVerify: typeof bls.popVerify === 'function' ? (pk, proof) => bls.popVerify(pk, proof) : null,
    };
  }

  async function loadNobleBls() {
    const mod = await import('https://esm.sh/@noble/curves@1.4.0/bls12-381.js');
    const noble = mod?.bls12_381;
    if (!noble) {
      return null;
    }
    return {
      name: 'noble',
      getPublicKey: (sk) => noble.getPublicKey(sk),
      sign: (sk, msg) => noble.sign(msg, sk),
      verify: (pk, msg, sig) => noble.verify(sig, msg, pk),
      aggregateSignatures: (sigs) => noble.aggregateSignatures(sigs),
      aggregateVerify: (pks, msgs, aggSig) => noble.aggregateVerify(pks, msgs, aggSig),
      fastAggregateVerify: (pks, msg, aggSig) => noble.fastAggregateVerify(pks, msg, aggSig),
      popProve: typeof noble.popProve === 'function' ? (sk) => noble.popProve(sk) : null,
      popVerify: typeof noble.popVerify === 'function' ? (pk, proof) => noble.popVerify(pk, proof) : null,
    };
  }

  function wrapBlsProvider(base) {
    if (!base) {
      return null;
    }
    return {
      name: base.name,
      getPublicKey: async (skBytes) => ensureUint8Array(await base.getPublicKey(skBytes), 'public key'),
      sign: async (skBytes, msgBytes) => ensureUint8Array(await base.sign(skBytes, msgBytes), 'signature'),
      verify: async (pkBytes, msgBytes, sigBytes) => Boolean(await base.verify(pkBytes, msgBytes, sigBytes)),
      aggregateSignatures: async (signatures) => ensureUint8Array(await base.aggregateSignatures(signatures), 'aggregate signature'),
      aggregateVerify: async (publicKeys, messages, aggregateSignature) => Boolean(await base.aggregateVerify(publicKeys, messages, aggregateSignature)),
      fastAggregateVerify: async (publicKeys, message, aggregateSignature) => Boolean(await base.fastAggregateVerify(publicKeys, message, aggregateSignature)),
      popProve: base.popProve ? async (skBytes) => ensureUint8Array(await base.popProve(skBytes), 'proof-of-possession') : null,
      popVerify: base.popVerify ? async (pkBytes, proofBytes) => Boolean(await base.popVerify(pkBytes, proofBytes)) : null,
    };
  }

  async function ensureBls() {
    if (blsProvider) {
      return blsProvider;
    }
    if (blsInitPromise) {
      return blsInitPromise;
    }
    blsInitPromise = (async () => {
      try {
        const chainsafe = wrapBlsProvider(await loadChainsafeBls());
        if (chainsafe) {
          blsProviderName = chainsafe.name;
          return chainsafe;
        }
      } catch (error) {
        console.warn('Chainsafe BLS load failed', error);
      }
      const noble = wrapBlsProvider(await loadNobleBls());
      if (noble) {
        blsProviderName = noble.name;
        return noble;
      }
      throw new Error('Unable to initialize a BLS library.');
    })().then((provider) => {
      blsProvider = provider;
      return provider;
    }).catch((error) => {
      blsInitPromise = null;
      throw error;
    });
    return blsInitPromise;
  }

  async function pkFromSk(skHex) {
    const sk = normalizeHex(skHex);
    const skBytes = hexToBytes(sk);
    assertBytesLength(skBytes, 32, 'Secret key');
    const bls = await ensureBls();
    const pkBytes = await bls.getPublicKey(skBytes);
    return bytesToHex(pkBytes);
  }

  async function blsSign(skHex, msg32) {
    if (!(msg32 instanceof Uint8Array)) {
      throw new Error('Message must be a 32-byte Uint8Array.');
    }
    assertBytesLength(msg32, 32, 'Message');
    const skBytes = hexToBytes(normalizeHex(skHex));
    assertBytesLength(skBytes, 32, 'Secret key');
    const bls = await ensureBls();
    const sigBytes = await bls.sign(skBytes, msg32);
    return bytesToHex(sigBytes);
  }

  async function blsVerify(pkHex, msg32, sigHex) {
    if (!(msg32 instanceof Uint8Array)) {
      throw new Error('Message must be a 32-byte Uint8Array.');
    }
    assertBytesLength(msg32, 32, 'Message');
    const pkBytes = hexToBytes(normalizeHex(pkHex));
    const sigBytes = hexToBytes(normalizeHex(sigHex));
    const bls = await ensureBls();
    return bls.verify(pkBytes, msg32, sigBytes);
  }

  async function blsAggregateSigs(sigHexArray) {
    if (!Array.isArray(sigHexArray) || sigHexArray.length === 0) {
      throw new Error('Provide at least one signature to aggregate.');
    }
    const bls = await ensureBls();
    const signatures = sigHexArray.map((sig) => hexToBytes(normalizeHex(sig)));
    const aggregate = await bls.aggregateSignatures(signatures);
    return bytesToHex(aggregate);
  }

  async function computeAugmentedMessage(pkBytes, digest32) {
    assertBytesLength(digest32, 32, 'Attestation digest');
    const combined = new Uint8Array(pkBytes.length + digest32.length);
    combined.set(pkBytes, 0);
    combined.set(digest32, pkBytes.length);
    return hashBytes(combined);
  }

  async function blsAggregateVerifyAug(pkHexArray, digest32, sigHexArray) {
    if (!Array.isArray(pkHexArray) || !Array.isArray(sigHexArray) || pkHexArray.length !== sigHexArray.length) {
      throw new Error('Mismatch between signer public keys and signatures.');
    }
    if (!(digest32 instanceof Uint8Array)) {
      throw new Error('Digest must be a Uint8Array.');
    }
    assertBytesLength(digest32, 32, 'Attestation digest');
    const bls = await ensureBls();
    const publicKeys = pkHexArray.map((pk) => hexToBytes(normalizeHex(pk)));
    const signatures = sigHexArray.map((sig) => hexToBytes(normalizeHex(sig)));
    const messages = [];
    for (let i = 0; i < publicKeys.length; i += 1) {
      // eslint-disable-next-line no-await-in-loop
      messages.push(await computeAugmentedMessage(publicKeys[i], digest32));
    }
    const aggregate = await bls.aggregateSignatures(signatures);
    const ok = await bls.aggregateVerify(publicKeys, messages, aggregate);
    return { ok, aggregate: bytesToHex(aggregate) };
  }

  async function blsFastAggregateVerifyPop(pkHexArray, digest32, aggSigHex) {
    if (!Array.isArray(pkHexArray) || pkHexArray.length === 0) {
      throw new Error('Provide at least one public key.');
    }
    if (!(digest32 instanceof Uint8Array)) {
      throw new Error('Digest must be a Uint8Array.');
    }
    assertBytesLength(digest32, 32, 'Attestation digest');
    const bls = await ensureBls();
    const publicKeys = pkHexArray.map((pk) => hexToBytes(normalizeHex(pk)));
    const aggregateSig = hexToBytes(normalizeHex(aggSigHex));
    return bls.fastAggregateVerify(publicKeys, digest32, aggregateSig);
  }

  async function blsPopProve(skHex) {
    const bls = await ensureBls();
    if (!bls.popProve) {
      throw new Error('Proof-of-possession helpers unavailable in this BLS build.');
    }
    const skBytes = hexToBytes(normalizeHex(skHex));
    assertBytesLength(skBytes, 32, 'Secret key');
    const proofBytes = await bls.popProve(skBytes);
    return bytesToHex(proofBytes);
  }

  async function blsPopVerify(pkHex, popHex) {
    const bls = await ensureBls();
    if (!bls.popVerify) {
      throw new Error('Proof-of-possession helpers unavailable in this BLS build.');
    }
    const pkBytes = hexToBytes(normalizeHex(pkHex));
    const popBytes = hexToBytes(normalizeHex(popHex));
    return bls.popVerify(pkBytes, popBytes);
  }

  function buildAttestationPayload(meeting, merkleRoot, mode) {
    if (!meeting || !meeting.meeting_id || !meeting.timestamp || !merkleRoot) {
      return null;
    }
    const root = normalizeHex(merkleRoot);
    if (!/^[0-9a-f]{64}$/.test(root)) {
      throw new Error('Merkle root must be a 32-byte hex string.');
    }
    const aggMode = mode === BLS_MODES.POP ? BLS_MODES.POP : BLS_MODES.AUG;
    return {
      context: BLS_CONTEXT,
      meeting_id: meeting.meeting_id,
      timestamp: meeting.timestamp,
      merkle_root: root,
      hash_alg: 'SHA-256',
      sig_scheme: 'BLS',
      agg_scheme: aggMode,
    };
  }

  function attestationToCanonicalJson(attestation) {
    if (!attestation) {
      return '';
    }
    const ordered = {
      context: attestation.context,
      meeting_id: attestation.meeting_id,
      timestamp: attestation.timestamp,
      merkle_root: attestation.merkle_root,
      hash_alg: attestation.hash_alg,
      sig_scheme: attestation.sig_scheme,
      agg_scheme: attestation.agg_scheme,
    };
    return JSON.stringify(ordered);
  }

  async function computeAttestationDigest(attestation) {
    if (!attestation) {
      throw new Error('No attestation to hash.');
    }
    const canonical = attestationToCanonicalJson(attestation);
    // Domain separation keeps signatures scoped to Merkle-Meet attestations.
    const prefixBytes = encoder.encode(BLS_PREFIX);
    const bodyBytes = encoder.encode(canonical);
    const input = new Uint8Array(prefixBytes.length + bodyBytes.length);
    input.set(prefixBytes, 0);
    input.set(bodyBytes, prefixBytes.length);
    return hashBytes(input);
  }

  async function hashLeaf(item, salt) {
    const payload = salt ? `${salt}\n${item.agenda}\n${item.notes}` : `${item.agenda}\n${item.notes}`;
    return hashUtf8(payload);
  }

  async function hashInternal(left, right) {
    const combined = new Uint8Array(left.length + right.length);
    combined.set(left, 0);
    combined.set(right, left.length);
    return hashBytes(combined);
  }

  async function buildLevels(items, salt) {
    let current = await Promise.all(items.map((item) => hashLeaf(item, salt)));
    const levels = [current];
    while (current.length > 1) {
      const next = [];
      for (let i = 0; i < current.length; i += 2) {
        const left = current[i];
        const right = current[i + 1] ?? current[i];
        // eslint-disable-next-line no-await-in-loop
        next.push(await hashInternal(left, right));
      }
      current = next;
      levels.push(current);
    }
    return levels;
  }

  async function buildTree(items, salt) {
    const levels = await buildLevels(items, salt);
    return {
      levels,
      leaves: levels[0].map(bytesToHex),
      root: bytesToHex(levels[levels.length - 1][0]),
      levelCounts: levels.map((level) => level.length),
    };
  }

  async function buildTreeFromData(data, saltOverride) {
    const meeting = normalizeMeetingObject(data, saltOverride);
    const tree = await buildTree(meeting.items, meeting.salt);
    return { meeting, tree };
  }

  function generateProofFromLevels(levels, index) {
    const proof = [];
    let currentIndex = index;
    for (let level = 0; level < levels.length - 1; level += 1) {
      const layer = levels[level];
      const isRight = currentIndex % 2 === 1;
      const siblingIndex = isRight ? currentIndex - 1 : currentIndex + 1;
      const sibling = layer[siblingIndex] ?? layer[currentIndex];
      proof.push({
        position: isRight ? 'left' : 'right',
        hash: bytesToHex(sibling),
      });
      currentIndex = Math.floor(currentIndex / 2);
    }
    return proof;
  }

  function normalizeProofStep(entry, index) {
    if (!isPlainObject(entry)) {
      throw new Error(`Proof step ${index} must be an object`);
    }
    const position = entry.position;
    if (position !== 'left' && position !== 'right') {
      throw new Error(`Proof step ${index} must specify position "left" or "right"`);
    }
    const hash = entry.hash;
    if (typeof hash !== 'string') {
      throw new Error(`Proof step ${index} must include a hash string`);
    }
    if (!/^[0-9a-f]{64}$/i.test(hash)) {
      throw new Error(`Proof step ${index} hash must be a 32-byte hex string`);
    }
    return { position, hash: hash.toLowerCase() };
  }

  async function reduceProof(leafBytes, proofSteps) {
    let current = leafBytes;
    for (const step of proofSteps) {
      const sibling = hexToBytes(step.hash);
      // eslint-disable-next-line no-await-in-loop
      current = step.position === 'left'
        ? await hashInternal(sibling, current)
        : await hashInternal(current, sibling);
    }
    return current;
  }

  const defaultApi = {
    async computeRoot(data, options = {}) {
      const { meeting, tree } = await buildTreeFromData(data, options.salt);
      return {
        root: tree.root,
        leafCount: tree.leaves.length,
        levelCounts: tree.levelCounts,
        leaves: tree.leaves,
        meeting,
      };
    },
    async verifyRoot(data, expectedRoot, options = {}) {
      const target = (expectedRoot || '').toLowerCase();
      if (!/^[0-9a-f]{64}$/.test(target)) {
        throw new Error('Expected root must be a 32-byte hex string.');
      }
      const result = await this.computeRoot(data, options);
      return {
        match: result.root === target,
        computedRoot: result.root,
        leafCount: result.leafCount,
        levelCounts: result.levelCounts,
        leaves: result.leaves,
        meeting: result.meeting,
      };
    },
    async generateProof(data, index, options = {}) {
      if (!Number.isInteger(index) || index < 0) {
        throw new Error('Index must be a non-negative integer');
      }
      const { meeting, tree } = await buildTreeFromData(data, options.salt);
      if (index >= meeting.items.length) {
        throw new Error(`Index ${index} is out of bounds for items array of length ${meeting.items.length}`);
      }
      const proof = generateProofFromLevels(tree.levels, index);
      const document = {
        meeting_id: meeting.meeting_id,
        timestamp: meeting.timestamp,
        salt: meeting.salt,
        index,
        item: meeting.items[index],
        leaf: tree.leaves[index],
        proof,
        root: tree.root,
      };
      return { document, pathLength: proof.length };
    },
    async verifyProof(proofDoc, expectedRoot) {
      if (!isPlainObject(proofDoc)) {
        throw new Error('Proof must be a JSON object');
      }
      const canonical = normalizeMeetingObject({
        meeting_id: proofDoc.meeting_id,
        timestamp: proofDoc.timestamp,
        salt: proofDoc.salt,
        items: [proofDoc.item],
      });
      const canonicalItem = canonical.items[0];
      const canonicalLeaf = bytesToHex(await hashLeaf(canonicalItem, canonical.salt));
      const providedLeaf = typeof proofDoc.leaf === 'string' ? proofDoc.leaf.toLowerCase() : '';
      if (canonicalLeaf !== providedLeaf) {
        return {
          valid: false,
          reason: 'leaf-mismatch',
          computedLeaf: canonicalLeaf,
          providedLeaf,
        };
      }
      if (!Array.isArray(proofDoc.proof)) {
        throw new Error('Proof proof must be an array');
      }
      const proofSteps = proofDoc.proof.map((entry, idx) => normalizeProofStep(entry, idx));
      const leafBytes = hexToBytes(canonicalLeaf);
      const computedRootBytes = await reduceProof(leafBytes, proofSteps);
      const computedRoot = bytesToHex(computedRootBytes);
      const targetRoot = (expectedRoot || proofDoc.root || '').toLowerCase();
      if (!/^[0-9a-f]{64}$/.test(targetRoot)) {
        throw new Error('Expected root must be a 32-byte hex string.');
      }
      return {
        valid: computedRoot === targetRoot,
        computedRoot,
        expectedRoot: targetRoot,
      };
    },
  };

  const resolveApi = () => window.MerkleMeet || window.MeetingMerkle || defaultApi;

  if (!window.MerkleMeet && !window.MeetingMerkle) {
    window.MerkleMeet = defaultApi;
  }

  if (!window.MeetingMerkle) {
    window.MeetingMerkle = window.MerkleMeet;
  }

  const log = (msg, cls = '') => {
    const placeholder = document.getElementById('empty-line');
    if (placeholder) {
      placeholder.remove();
    }
    const line = document.createElement('div');
    line.className = `line ${cls}`.trim();
    line.textContent = msg;
    feed.appendChild(line);
    feed.scrollTop = feed.scrollHeight;
  };

  const copy = async (text) => {
    if (!text) {
      log('> nothing to copy', 'bad');
      return;
    }
    try {
      await navigator.clipboard.writeText(text);
      log('> copied to clipboard', 'ok');
    } catch (error) {
      log('> clipboard not available', 'bad');
    }
  };

  const notWired = (fn) => {
    log(`> ${fn} not wired. Provide window.MerkleMeet.${fn}()`, 'bad');
  };

  const themeToggle = document.getElementById('theme-toggle');
  const THEME_KEY = 'merkle-meet-theme';
  const THEME_ICONS = {
    light: `
      <svg viewBox="0 0 24 24" aria-hidden="true" focusable="false">
        <circle cx="12" cy="12" r="4.5" fill="none"></circle>
        <line x1="12" y1="2" x2="12" y2="5"></line>
        <line x1="12" y1="19" x2="12" y2="22"></line>
        <line x1="4.22" y1="4.22" x2="6.34" y2="6.34"></line>
        <line x1="17.66" y1="17.66" x2="19.78" y2="19.78"></line>
        <line x1="2" y1="12" x2="5" y2="12"></line>
        <line x1="19" y1="12" x2="22" y2="12"></line>
        <line x1="4.22" y1="19.78" x2="6.34" y2="17.66"></line>
        <line x1="17.66" y1="6.34" x2="19.78" y2="4.22"></line>
      </svg>`,
    dark: `
      <svg viewBox="0 0 24 24" aria-hidden="true" focusable="false">
        <path d="M21 12.79A9 9 0 0111.21 3a7 7 0 109.79 9.79z" fill="none"></path>
      </svg>`,
  };

  const applyTheme = (theme) => {
    const normalized = theme === 'light' ? 'light' : 'dark';
    if (normalized === 'light') {
      document.documentElement.setAttribute('data-theme', 'light');
    } else {
      document.documentElement.removeAttribute('data-theme');
    }
    try {
      localStorage.setItem(THEME_KEY, normalized);
    } catch (_) {
      /* ignore storage failures */
    }
    if (themeToggle) {
      const icon = normalized === 'light' ? THEME_ICONS.light : THEME_ICONS.dark;
      const nextTheme = normalized === 'light' ? 'dark' : 'light';
      const label = `Switch to ${nextTheme} theme`;
      themeToggle.innerHTML = icon;
      themeToggle.setAttribute('aria-label', label);
      themeToggle.setAttribute('title', label);
      themeToggle.setAttribute('aria-pressed', normalized === 'light' ? 'true' : 'false');
      themeToggle.dataset.theme = normalized;
    }
  };

  const storedTheme = (() => {
    try {
      return localStorage.getItem(THEME_KEY);
    } catch (_) {
      return null;
    }
  })();
  const prefersDark = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
  applyTheme(storedTheme ?? (prefersDark ? 'dark' : 'light'));

  themeToggle?.addEventListener('click', () => {
    const current = themeToggle.dataset.theme || (document.documentElement.getAttribute('data-theme') === 'light' ? 'light' : 'dark');
    const next = current === 'light' ? 'dark' : 'light';
    applyTheme(next);
    log(`> theme set to ${next}`, 'ok');
  });

  function setIntegrity(state, message) {
    dot.classList.remove('ok', 'bad');
    integrityLabel?.classList.remove('ok', 'error');

    if (state === 'ok') {
      dot.classList.add('ok');
      if (integrityLabel) {
        integrityLabel.textContent = message || 'Root ready';
        integrityLabel.classList.add('ok');
      }
      dot.setAttribute('aria-label', 'Integrity status: root verified');
    } else if (state === 'bad') {
      dot.classList.add('bad');
      if (integrityLabel) {
        integrityLabel.textContent = message || 'Root mismatch';
        integrityLabel.classList.add('error');
      }
      dot.setAttribute('aria-label', 'Integrity status: root mismatch');
    } else {
      if (integrityLabel) {
        integrityLabel.textContent = message || '';
      }
      dot.setAttribute('aria-label', 'Integrity status: idle');
    }
  }

  function stepLog(step, message, cls = '') {
    log(`${step} ‚ñ∏ ${message}`, cls);
  }

  function updateAgendaList() {
    if (!itemsOverview) return;
    let parsed;
    try {
      parsed = JSON.parse(jsonBox.value || 'null');
    } catch (_) {
      itemsOverview.innerHTML = '<div class="small" data-empty>Agenda items appear here after loading minutes.</div>';
      return;
    }
    if (parsed && typeof parsed === 'object' && typeof parsed.salt === 'string' && parsed.salt && !saltInput.value) {
      saltInput.value = parsed.salt;
    }
    const items = parsed && Array.isArray(parsed.items) ? parsed.items : [];
    if (!items.length) {
      itemsOverview.innerHTML = '<div class="small" data-empty>No agenda items detected yet.</div>';
      if (proofIndexInput) {
        proofIndexInput.value = '';
      }
      return;
    }

    if (selectedProofIndex >= items.length) {
      selectedProofIndex = 0;
    }

    const fragment = document.createDocumentFragment();
    items.forEach((item, index) => {
      const label = document.createElement('label');
      const radio = document.createElement('input');
      radio.type = 'radio';
      radio.name = 'proof-item';
      radio.value = String(index);
      if (index === selectedProofIndex) {
        radio.checked = true;
      }
      radio.addEventListener('change', () => {
        selectedProofIndex = Number.parseInt(radio.value, 10);
        proofIndexInput.value = String(selectedProofIndex);
      });

      const content = document.createElement('div');
      content.className = 'item-body';
      const title = document.createElement('span');
      title.className = 'item-title';
      title.textContent = item.agenda || `Item ${index}`;
      const notes = document.createElement('span');
      notes.className = 'item-notes';
      notes.textContent = (item.notes || '').slice(0, 120);

      content.appendChild(title);
      if (item.notes) {
        content.appendChild(notes);
      }

      label.appendChild(radio);
      label.appendChild(content);
      fragment.appendChild(label);
    });

    itemsOverview.innerHTML = '';
    itemsOverview.appendChild(fragment);
    if (proofIndexInput) {
      proofIndexInput.value = String(selectedProofIndex);
    }
  }

  function resetFeedChecklist() {
    if (!feed) return;
    feed.innerHTML = '<ul class="small" id="empty-line"><li>1. Load or convert minutes JSON.</li><li>2. Compute the Merkle root (salt optional).</li><li>3. Share or verify proofs as needed.</li></ul>';
  }

  function getDesiredProofIndex() {
    const checked = itemsOverview?.querySelector('input[name="proof-item"]:checked');
    if (checked) {
      return Number.parseInt(checked.value, 10);
    }
    const manual = Number.parseInt(proofIndexInput.value, 10);
    return Number.isInteger(manual) && manual >= 0 ? manual : null;
  }

  function parseMeetingInput({ logSuccess = true } = {}) {
    let data;
    try {
      data = JSON.parse(jsonBox.value);
      if (logSuccess) {
        stepLog('Step 1', 'Parsed minutes JSON', 'ok');
      }
      return data;
    } catch (error) {
      stepLog('Step 1', "Couldn't parse JSON. Check for trailing commas or mismatched quotes.", 'bad');
      return null;
    }
  }

  async function computeRootFlow({ meetingOverride } = {}) {
    const meetingData = meetingOverride || parseMeetingInput();
    if (!meetingData) {
      return null;
    }

    if (meetingData.salt && !saltInput.value) {
      saltInput.value = meetingData.salt;
    }

    const api = resolveApi();
    if (!api?.computeRoot) {
      notWired('computeRoot');
      return null;
    }

    try {
      const salt = saltInput.value.trim() || meetingData.salt || undefined;
      stepLog('Step 2', 'Canonicalizing JSON ‚Ä¶ OK', 'ok');
      const result = await api.computeRoot(meetingData, { salt });
      stepLog('Step 2', `Hashing ${result.leafCount} items with SHA-256 ‚Ä¶ OK`, 'ok');
      stepLog('Step 2', `Merkle levels: ${result.levelCounts.join(' ‚Üí ')}`, 'ok');
      stepLog('Step 2', `ROOT = ${result.root} (hex)`, 'ok');
      rootCode.textContent = result.root;
      latestMeeting = result;
      await refreshAttestationPreview();
      setIntegrity('ok', 'Root computed');
      updateAgendaList();
      return result;
    } catch (error) {
      stepLog('Step 2', `computeRoot failed: ${error.message || error}`, 'bad');
      setIntegrity('bad', 'Root failed');
      return null;
    }
  }

  async function generateProofFlow(index, { meetingOverride } = {}) {
    const meetingData = meetingOverride || parseMeetingInput({ logSuccess: false });
    if (!meetingData) {
      return null;
    }
    if (!Number.isInteger(index) || index < 0) {
      stepLog('Step 6', 'Select an agenda item first (use the radio list).', 'bad');
      return null;
    }
    if (!Array.isArray(meetingData.items) || index >= meetingData.items.length) {
      stepLog('Step 6', 'Item index is out of bounds for the current minutes.', 'bad');
      return null;
    }
    const api = resolveApi();
    if (!api?.generateProof) {
      notWired('generateProof');
      return null;
    }
    try {
      const salt = saltInput.value.trim() || meetingData.salt || undefined;
      const result = await api.generateProof(meetingData, index, { salt });
      const agenda = meetingData.items[index]?.agenda ?? `Item #${index}`;
      stepLog('Step 6', `Generated proof for ‚Äú${agenda}‚Äù (path length = ${result.pathLength})`, 'ok');
      out.value = JSON.stringify(result.document, null, 2);
      latestProofDocument = result.document;
      selectedProofIndex = index;
      proofIndexInput.value = String(index);
      updateAgendaList();
      return result;
    } catch (error) {
      stepLog('Step 6', `generateProof failed: ${error.message || error}`, 'bad');
      return null;
    }
  }

  async function verifyProofDocumentFlow(proofDoc, expectedRoot, { addSummary = true } = {}) {
    const api = resolveApi();
    if (!api?.verifyProof) {
      notWired('verifyProof');
      return { valid: false };
    }
    try {
      const result = await api.verifyProof(proofDoc, expectedRoot);
      if (result.valid) {
        setIntegrity('ok', 'Proof verified');
        stepLog('Step 7', 'Proof matches the expected root', 'ok');
        if (addSummary && proofDoc?.item) {
          const summary = `This proof shows that ‚Äú${proofDoc.item.agenda}‚Äù was part of meeting ${proofDoc.meeting_id} at ${proofDoc.timestamp}.`;
          stepLog('Step 7', summary, 'ok');
          out.value = `${JSON.stringify(proofDoc, null, 2)}\n\n${summary}`;
        }
      } else {
        setIntegrity('bad', 'Mismatch vs expected root');
        stepLog('Step 7', 'Proof did not match the expected root', 'bad');
      }
      return result;
    } catch (error) {
      stepLog('Step 7', `verifyProof failed: ${error.message || error}`, 'bad');
      setIntegrity('bad', 'Proof failed');
      return { valid: false };
    }
  }

  function prepareSlackMessage(meeting, root) {
    return [
      'Merkle Meet üõ°Ô∏è',
      `Meeting: ${meeting.meeting_id || '‚Äî'}`,
      `Timestamp: ${meeting.timestamp || '‚Äî'}`,
      `Merkle Root: ${root}`,
      '',
      'Anyone can verify locally: compute the root from the minutes JSON and compare to the above.',
    ].join('\n');
  }

  function downloadJsonFile(filename, data) {
    const blob = new Blob([data], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const link = document.createElement('a');
    link.href = url;
    link.download = filename;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    URL.revokeObjectURL(url);
  }

  const exampleDefaultId = 'protocol-art';
  const exampleSets = [
    {
      id: 'protocol-art',
      title: 'Protocol Art Salon',
      summary: 'Foundations of protocol art, historical references, and taxonomy axes.',
      meeting: {
        meeting_id: 'Protocol-Art-Salon-2025-09-17',
        timestamp: '2025-09-17T18:00:00Z',
        salt: 'sop-demo-protocol-art',
        items: [
          { agenda: 'Define protocol art foundations', notes: 'Explored the shift from autographic works to allographic collaborations and the orchestrator role of artists.' },
          { agenda: 'Historical references', notes: 'Discussed Moholy-Nagy telephone pictures, Sol LeWitt wall drawings, and instruction-driven performance protocols.' },
          { agenda: 'Digital mediums', notes: 'Covered collaborative canvases, generative AI voice models, and smart-contract choreography as protocol art.' },
          { agenda: 'Taxonomy axes', notes: 'Mapped atomic‚Üísystemic, strict‚Üífluid, and technical‚Üísocial spectrums for categorizing protocol art.' },
        ],
      },
    },
    {
      id: 'protocol-fiction',
      title: 'Protocol Fiction Workshop',
      summary: 'Protocol-driven storytelling framework and breakout structure for sci-fi narratives.',
      meeting: {
        meeting_id: 'Protocol-Fiction-Workshop-2025-09-17',
        timestamp: '2025-09-17T16:00:00Z',
        salt: 'sop-demo-protocol-fiction',
        items: [
          { agenda: 'Workshop framing', notes: 'Outlined protocol fiction as shared author-reader conventions plus hierarchy of narrative protocol difficulty.' },
          { agenda: 'Causal layer analysis', notes: 'Reviewed the four-layer method using ‚ÄúThe Golden Elephant‚Äù as a case study to connect surface, system, worldview, and myth.' },
          { agenda: 'Breakout structure', notes: 'Walked through Seed‚ÜíRoot‚ÜíFlower‚ÜíFruit rounds and concepts like neural interface privacy and AI legal houses.' },
          { agenda: 'Assignments and deliverables', notes: 'Participants to submit a 1,000-word story, documenting AI usage and reflections on co-creation.' },
        ],
      },
    },
    {
      id: 'agentic-web',
      title: 'Agentic Web Trust Protocols',
      summary: 'Trust frameworks for AI agents plus design gaps and experience layers.',
      meeting: {
        meeting_id: 'Agentic-Web-Trust-2025-09-18',
        timestamp: '2025-09-18T15:00:00Z',
        salt: 'sop-demo-agentic-web',
        items: [
          { agenda: 'Trust frameworks', notes: 'Compared value-based and proof-based trust, plus how technology mediates human relationships.' },
          { agenda: 'Rise of the agentic web', notes: 'Forecasted billions of autonomous AI agents across governance, finance, healthcare, legal, and education domains.' },
          { agenda: 'Protocol gaps', notes: 'Highlighted missing behavior verification, misbehavior handling, and cross-platform interoperability for AI agents.' },
          { agenda: 'Experience design stack', notes: 'Introduced evidence‚Üítrust primitives‚Üírituals framework and trust experience dimensions like epistemic verification.' },
        ],
      },
    },
    {
      id: 'llm-roleplay',
      title: 'LLM Role-Playing Lab',
      summary: 'Protocol studies pipeline with LLM simulations and workshop takeaways.',
      meeting: {
        meeting_id: 'LLM-Protocol-Studies-2025-09-16',
        timestamp: '2025-09-16T17:30:00Z',
        salt: 'sop-demo-llm-roleplay',
        items: [
          { agenda: 'Program overview', notes: 'Martin Harrigan outlined integrating protocol studies into blockchain curricula and workshop goals.' },
          { agenda: 'Analysis pipeline', notes: 'Reviewed transcription of Summer of Protocols content, embeddings, and clustered concept outputs.' },
          { agenda: 'Evaluation framework', notes: 'Enumerated ten protocol properties and role-playing workflow for testing defensibility and mortality.' },
          { agenda: 'Exercise learnings', notes: 'Captured strengths, weaknesses, and participant observations from the LLM simulations.' },
        ],
      },
    },
  ];

  function closeExampleOverlay() {
    if (!exampleOverlay) return;
    exampleOverlay.classList.remove('open');
    exampleOverlay.setAttribute('aria-hidden', 'true');
    if (!transcriptOverlay?.classList.contains('open')) {
      document.body.classList.remove('modal-open');
    }
  }

  function openExampleOverlay() {
    if (!exampleOverlay) return;
    closeTranscriptOverlay();
    renderExampleCards();
    exampleOverlay.classList.add('open');
    exampleOverlay.setAttribute('aria-hidden', 'false');
    document.body.classList.add('modal-open');
    const defaultButton = document.getElementById(`example-load-${exampleDefaultId}`);
    defaultButton?.focus();
  }

  function loadExampleMeeting(meeting, { stepLabel = 'Step 1' } = {}) {
    jsonBox.value = JSON.stringify(meeting, null, 2);
    saltInput.value = meeting.salt || '';
    selectedProofIndex = 0;
    if (proofIndexInput) {
      proofIndexInput.value = '';
    }
    latestProofDocument = null;
    latestMeeting = null;
    rootCode.textContent = '‚Äî';
    out.value = '';
    resetFeedChecklist();
    updateAgendaList();
    if (itemsOverview) {
      itemsOverview.scrollTop = 0;
    }
    setIntegrity(null);
    stepLog(stepLabel, `Loaded example minutes: ${meeting.meeting_id}`, 'ok');
    stepLog(stepLabel, 'Next: Step 2 ‚Üí Compute the Merkle root.', '');
    closeExampleOverlay();
  }

  function renderExampleCards() {
    if (!exampleGrid || exampleGrid.dataset.rendered === 'true') {
      return;
    }
    exampleGrid.innerHTML = '';
    exampleSets.forEach((entry) => {
      const card = document.createElement('article');
      card.className = 'example-card';
      card.id = `example-card-${entry.id}`;
      card.setAttribute('role', 'listitem');

      const title = document.createElement('h3');
      title.textContent = entry.title;
      const meta = document.createElement('p');
      meta.className = 'small mono';
      meta.textContent = `${entry.meeting.meeting_id} ‚Ä¢ ${entry.meeting.timestamp}`;
      const summary = document.createElement('p');
      summary.textContent = entry.summary;

      const agendaPreview = document.createElement('p');
      agendaPreview.className = 'small';
      agendaPreview.textContent = entry.meeting.items.slice(0, 2).map((item) => `‚Ä¢ ${item.agenda}`).join('   ');

      const footer = document.createElement('footer');
      const loadButton = document.createElement('button');
      loadButton.className = 'primary';
      loadButton.id = `example-load-${entry.id}`;
      loadButton.type = 'button';
      loadButton.textContent = 'Load into Step 1';
      loadButton.addEventListener('click', () => {
        loadExampleMeeting(entry.meeting, { stepLabel: 'Step 1' });
      });

      const copyButton = document.createElement('button');
      copyButton.type = 'button';
      copyButton.textContent = 'Copy JSON';
      copyButton.addEventListener('click', () => {
        copy(JSON.stringify(entry.meeting, null, 2));
        stepLog('Step 1', `Copied ${entry.meeting.meeting_id} JSON`, 'ok');
      });

      footer.appendChild(loadButton);
      footer.appendChild(copyButton);

      card.appendChild(title);
      card.appendChild(meta);
      card.appendChild(summary);
      card.appendChild(agendaPreview);
      card.appendChild(footer);
      exampleGrid.appendChild(card);
    });
    exampleGrid.dataset.rendered = 'true';
  }

  btnExampleClose?.addEventListener('click', () => {
    closeExampleOverlay();
  });

  exampleOverlay?.addEventListener('click', (event) => {
    if (event.target === exampleOverlay) {
      closeExampleOverlay();
    }
  });

  const stepDetails = Array.from(document.querySelectorAll('.step'));
  const stepHelpButtons = document.querySelectorAll('.step-help');
  let selectedProofIndex = 0;
  let latestProofDocument = null;
  let latestMeeting = null;
  let lastTranscriptItemsCount = 0;
  let agendaDebounce;
  const blsPopCache = new Map();
  const blsState = {
    mode: BLS_MODES.AUG,
    attestation: null,
    digest: null,
    canonicalJson: '',
    signers: [],
    aggregate: null,
    lastSignature: null,
  };
  let blsBackendLogged = false;
  let blsPkDeriveTimer;

  function setBlsAggregateStatus(state, message) {
    if (!blsAggregateStatus) return;
    blsAggregateStatus.textContent = message || '';
    blsAggregateStatus.classList.remove('ok', 'bad');
    if (state === 'ok') {
      blsAggregateStatus.classList.add('ok');
    } else if (state === 'bad') {
      blsAggregateStatus.classList.add('bad');
    }
  }

  function clearBlsSignature() {
    blsState.lastSignature = null;
    if (blsSignatureTextarea) {
      blsSignatureTextarea.value = '';
    }
  }

  function clearBlsAggregate(resetIntegrity = false) {
    blsState.aggregate = null;
    if (blsAggregateTextarea) {
      blsAggregateTextarea.value = '';
    }
    setBlsAggregateStatus(null, '');
    if (resetIntegrity) {
      if (latestMeeting?.root) {
        setIntegrity('ok', 'Root computed');
      } else {
        setIntegrity(null);
      }
    }
  }

  function renderBlsSigners() {
    if (!blsSignersBody) return;
    blsSignersBody.innerHTML = '';
    if (blsSignersTable) {
      blsSignersTable.classList.toggle('has-pop', blsState.mode === BLS_MODES.POP);
    }
    if (blsState.mode === BLS_MODES.POP) {
      blsPopHeader?.removeAttribute('hidden');
    } else if (blsPopHeader) {
      blsPopHeader.setAttribute('hidden', 'hidden');
    }
    if (!blsState.signers.length) {
      const row = document.createElement('tr');
      row.dataset.empty = 'true';
      const cell = document.createElement('td');
      cell.colSpan = 4;
      cell.textContent = 'No signatures collected yet.';
      row.appendChild(cell);
      blsSignersBody.appendChild(row);
      return;
    }
    blsState.signers.forEach((entry, index) => {
      const row = document.createElement('tr');
      const pkCell = document.createElement('td');
      pkCell.textContent = entry.pk;
      row.appendChild(pkCell);
      const popCell = document.createElement('td');
      popCell.textContent = blsState.mode === BLS_MODES.POP ? (entry.pop || '‚Äî') : '‚Äî';
      row.appendChild(popCell);
      const sigCell = document.createElement('td');
      sigCell.textContent = entry.sig;
      row.appendChild(sigCell);
      const actionCell = document.createElement('td');
      actionCell.className = 'bls-actions-col';
      const removeButton = document.createElement('button');
      removeButton.type = 'button';
      removeButton.textContent = 'Remove';
      removeButton.addEventListener('click', () => {
        blsState.signers.splice(index, 1);
        renderBlsSigners();
        clearBlsAggregate(true);
      });
      actionCell.appendChild(removeButton);
      row.appendChild(actionCell);
      blsSignersBody.appendChild(row);
    });
  }

  function resetBlsCollections() {
    blsState.signers = [];
    blsPopCache.clear();
    renderBlsSigners();
    clearBlsAggregate(true);
    clearBlsSignature();
  }

  function updateBlsModeUI() {
    const isPop = blsState.mode === BLS_MODES.POP;
    if (blsPopSection) {
      if (isPop) {
        blsPopSection.removeAttribute('hidden');
      } else {
        blsPopSection.setAttribute('hidden', 'hidden');
        if (blsPopInput) {
          blsPopInput.value = '';
        }
      }
    }
    if (blsAddPopInput) {
      blsAddPopInput.style.display = isPop ? '' : 'none';
      if (!isPop) {
        blsAddPopInput.value = '';
      }
    }
    renderBlsSigners();
  }

  function setBlsMode(mode) {
    const next = mode === BLS_MODES.POP ? BLS_MODES.POP : BLS_MODES.AUG;
    if (blsState.mode === next) {
      return;
    }
    blsState.mode = next;
    updateBlsModeUI();
    resetBlsCollections();
    refreshAttestationPreview().catch((error) => {
      stepLog('Step 3', `Failed to refresh attestation: ${error.message || error}`, 'bad');
    });
  }

  function addSignerEntry(entry, { silent = false } = {}) {
    const pkHex = normalizeHex(entry.pk);
    const sigHex = normalizeHex(entry.sig);
    if (!pkHex) {
      throw new Error('Public key is required.');
    }
    if (!sigHex) {
      throw new Error('Signature is required.');
    }
    hexToBytes(pkHex);
    hexToBytes(sigHex);
    let popHex = null;
    if (entry.pop) {
      popHex = normalizeHex(entry.pop);
      if (popHex) {
        hexToBytes(popHex);
      }
    }
    if (blsState.mode === BLS_MODES.POP && !popHex) {
      throw new Error('Provide a PoP in proof-of-possession mode.');
    }
    const payload = popHex ? { pk: pkHex, sig: sigHex, pop: popHex } : { pk: pkHex, sig: sigHex };
    const existingIndex = blsState.signers.findIndex((item) => item.pk === pkHex);
    if (existingIndex >= 0) {
      blsState.signers.splice(existingIndex, 1, payload);
    } else {
      blsState.signers.push(payload);
    }
    renderBlsSigners();
    clearBlsAggregate(true);
    if (!silent) {
      stepLog('Step 3', `Added signer ${pkHex.slice(0, 8)}‚Ä¶`, 'ok');
    }
  }

  async function refreshAttestationPreview() {
    if (!blsAttestationTextarea) {
      return;
    }
    if (!latestMeeting?.meeting || !latestMeeting.root) {
      blsState.attestation = null;
      blsState.digest = null;
      blsState.canonicalJson = '';
      blsAttestationTextarea.value = 'Compute a Merkle root to populate the attestation JSON.';
      resetBlsCollections();
      return;
    }
    try {
      const attestation = buildAttestationPayload(latestMeeting.meeting, latestMeeting.root, blsState.mode);
      if (!attestation) {
        blsState.attestation = null;
        blsState.digest = null;
        blsState.canonicalJson = '';
        blsAttestationTextarea.value = 'Attestation unavailable. Ensure meeting metadata includes meeting_id and timestamp.';
        resetBlsCollections();
        return;
      }
      const canonical = attestationToCanonicalJson(attestation);
      blsState.attestation = attestation;
      blsState.canonicalJson = canonical;
      blsState.digest = await computeAttestationDigest(attestation);
      blsAttestationTextarea.value = canonical;
      resetBlsCollections();
    } catch (error) {
      blsState.attestation = null;
      blsState.digest = null;
      blsState.canonicalJson = '';
      blsAttestationTextarea.value = `Attestation error: ${error.message || error}`;
      resetBlsCollections();
    }
  }

  async function ensurePublicKey({ emitError = false } = {}) {
    if (blsPkInput) {
      const existing = normalizeHex(blsPkInput.value);
      if (existing) {
        return existing;
      }
    }
    const skHex = normalizeHex(blsSkInput?.value);
    if (skHex.length !== 64) {
      if (emitError) {
        stepLog('Step 3', 'Provide a 32-byte secret key first.', 'bad');
      }
      return null;
    }
    try {
      const pkHex = await pkFromSk(skHex);
      if (blsPkInput) {
        blsPkInput.value = pkHex;
      }
      return pkHex;
    } catch (error) {
      if (emitError) {
        stepLog('Step 3', `Failed to derive public key: ${error.message || error}`, 'bad');
      }
      return null;
    }
  }

  function schedulePublicKeyDerive() {
    if (!blsSkInput) {
      return;
    }
    clearTimeout(blsPkDeriveTimer);
    blsPkDeriveTimer = setTimeout(() => {
      const skHex = normalizeHex(blsSkInput.value);
      if (skHex.length === 64) {
        ensurePublicKey().catch(() => {});
      }
    }, 240);
  }

  async function ensureBlsBackendLogged() {
    await ensureBls();
    if (!blsBackendLogged && blsProviderName) {
      stepLog('Step 3', `Loaded ${blsProviderName} BLS backend`, 'ok');
      blsBackendLogged = true;
    }
  }

  stepHelpButtons.forEach((button) => {
    button.addEventListener('click', () => {
      const targetId = button.dataset.help;
      const target = targetId ? document.getElementById(targetId) : null;
      if (target) {
        target.classList.toggle('visible');
      }
    });
  });

  stepDetails.forEach((detail) => {
    detail.addEventListener('toggle', () => {
      if (detail.open) {
        detail.dataset.userOpen = 'true';
      }
    });
  });

  const accordionQuery = window.matchMedia('(max-width: 900px)');
  const syncAccordion = () => {
    if (accordionQuery.matches) {
      stepDetails.forEach((detail, index) => {
        if (!detail.dataset.userOpen) {
          detail.open = index === 0;
        }
      });
    } else {
      stepDetails.forEach((detail) => {
        detail.open = true;
        delete detail.dataset.userOpen;
      });
    }
  };
  if (typeof accordionQuery.addEventListener === 'function') {
    accordionQuery.addEventListener('change', syncAccordion);
  } else if (typeof accordionQuery.addListener === 'function') {
    accordionQuery.addListener(syncAccordion);
  }
  syncAccordion();

  const btnExample = document.getElementById('btn-example');
  const btnClear = document.getElementById('btn-clear');
  const btnCopyRoot = document.getElementById('btn-copy-root');
  const btnRoot = document.getElementById('btn-root');
  const btnSlack = document.getElementById('btn-slack');
  const btnVerifyRoot = document.getElementById('btn-verify-root');
  const btnProof = document.getElementById('btn-proof');
  const btnVerifyProof = document.getElementById('btn-verify-proof');
  const btnCopyOutput = document.getElementById('btn-copy-output');
  const proofIndexInput = document.getElementById('proof-index');
  const expectedRootInput = document.getElementById('expected-root');
  const saltInput = document.getElementById('salt');
  const whyLinks = document.querySelectorAll('.why-link');

  // Transcript converter elements
  const transcriptOverlay = document.getElementById('transcript-overlay');
  const btnTranscriptPanel = document.getElementById('btn-transcript-panel');
  const btnTranscriptClose = document.getElementById('btn-transcript-close');
  const btnParseTranscript = document.getElementById('btn-parse-transcript');
  const btnTranscriptCopy = document.getElementById('btn-transcript-copy');
  const btnTranscriptDownload = document.getElementById('btn-transcript-download');
  const btnTranscriptFill = document.getElementById('btn-transcript-fill');
  const meetingIdInput = document.getElementById('meeting-id');
  const meetingTsInput = document.getElementById('meeting-timestamp');
  const transcriptInput = document.getElementById('transcript');
  const transcriptJsonOutput = document.getElementById('transcript-json');
  const transcriptFileInput = document.getElementById('transcript-file');

  btnExample?.addEventListener('click', () => {
    openExampleOverlay();
  });

  btnClear?.addEventListener('click', () => {
    jsonBox.value = '';
    saltInput.value = '';
    out.value = '';
    rootCode.textContent = '‚Äî';
    selectedProofIndex = 0;
    updateAgendaList();
    resetFeedChecklist();
    blsState.attestation = null;
    blsState.digest = null;
    blsState.canonicalJson = '';
    if (blsAttestationTextarea) {
      blsAttestationTextarea.value = 'Compute a Merkle root to populate the attestation JSON.';
    }
    resetBlsCollections();
    setIntegrity(null);
    stepLog('Step 1', 'Cleared minutes and outputs', 'ok');
  });

  btnSaltGenerate?.addEventListener('click', () => {
    const bytes = new Uint8Array(16);
    crypto.getRandomValues(bytes);
    const salt = Array.from(bytes, (byte) => byte.toString(16).padStart(2, '0')).join('');
    saltInput.value = salt;
    stepLog('Step 2', 'Generated random salt', 'ok');
  });

  btnCopyRoot.addEventListener('click', () => copy(rootCode.textContent));

  jsonBox.addEventListener('input', () => {
    clearTimeout(agendaDebounce);
    agendaDebounce = setTimeout(() => {
      updateAgendaList();
    }, 250);
    blsState.attestation = null;
    blsState.digest = null;
    blsState.canonicalJson = '';
    if (blsAttestationTextarea) {
      blsAttestationTextarea.value = 'Compute a Merkle root to populate the attestation JSON.';
    }
    resetBlsCollections();
    setIntegrity(null);
  });

  btnRoot?.addEventListener('click', () => {
    computeRootFlow();
  });

  btnSlack?.addEventListener('click', () => {
    const meeting = parseMeetingInput({ logSuccess: false });
    if (!meeting) {
      return;
    }
    const root = rootCode.textContent;
    if (!root || root === '‚Äî') {
      stepLog('Step 4', 'Compute a root before composing the Slack message.', 'bad');
      return;
    }
    const message = prepareSlackMessage(meeting, root);
    out.value = message;
    stepLog('Step 4', 'Slack message prepared', 'ok');
  });

  btnSlackCopy?.addEventListener('click', () => {
    if (!out.value.trim()) {
      stepLog('Step 4', 'Compose a Slack message first', 'bad');
      return;
    }
    copy(out.value);
    stepLog('Step 4', 'Slack message copied to clipboard', 'ok');
  });

  btnVerifyRoot?.addEventListener('click', async () => {
    const data = parseMeetingInput({ logSuccess: false });
    if (!data) {
      return;
    }
    const expected = expectedRootInput.value.trim();
    if (!expected) {
      stepLog('Step 5', 'Enter an expected root to compare against.', 'bad');
      return;
    }
    const api = resolveApi();
    if (!api?.verifyRoot) {
      notWired('verifyRoot');
      return;
    }
    try {
      const salt = saltInput.value.trim() || data.salt || undefined;
      const result = await api.verifyRoot(data, expected, { salt });
      stepLog('Step 5', result.match ? 'Root matches the expected value' : 'Root mismatch detected', result.match ? 'ok' : 'bad');
      rootCode.textContent = result.computedRoot;
      latestMeeting = Object.assign({}, result, { root: result.computedRoot });
      await refreshAttestationPreview();
      setIntegrity(result.match ? 'ok' : 'bad', result.match ? 'Root matches expected root' : 'Mismatch vs expected root');
    } catch (error) {
      stepLog('Step 5', `verifyRoot failed: ${error.message || error}`, 'bad');
      setIntegrity('bad', 'Verification failed');
    }
  });

  btnProof?.addEventListener('click', () => {
    const index = getDesiredProofIndex();
    if (index === null) {
      stepLog('Step 6', 'Select an agenda item from the list or enter an index.', 'bad');
      return;
    }
    generateProofFlow(index);
  });

  btnProofCopy?.addEventListener('click', () => {
    if (!latestProofDocument) {
      stepLog('Step 6', 'Generate a proof before copying.', 'bad');
      return;
    }
    copy(JSON.stringify(latestProofDocument, null, 2));
    stepLog('Step 6', 'Proof JSON copied to clipboard', 'ok');
  });

  btnProofDownload?.addEventListener('click', () => {
    if (!latestProofDocument) {
      stepLog('Step 6', 'Generate a proof before downloading.', 'bad');
      return;
    }
    const fileName = `${(latestProofDocument.meeting_id || 'meeting').replace(/[^a-z0-9\-]+/gi, '_')}-proof.json`;
    downloadJsonFile(fileName, JSON.stringify(latestProofDocument, null, 2));
    stepLog('Step 6', 'Downloaded proof.json', 'ok');
  });

  btnTryIt?.addEventListener('click', () => {
    openExampleOverlay();
    stepLog('Demo', 'Pick an example meeting, then continue with Step 2 to compute the root.', 'ok');
  });

  btnVerifyProof?.addEventListener('click', async () => {
    let proof;
    try {
      proof = JSON.parse(out.value);
      stepLog('Step 7', 'Parsed proof JSON', 'ok');
    } catch (error) {
      stepLog('Step 7', 'Paste a proof JSON into Output first.', 'bad');
      return;
    }
    latestProofDocument = proof;
    const displayedRoot = rootCode.textContent;
    const expected = displayedRoot && displayedRoot !== '‚Äî' ? displayedRoot : undefined;
    await verifyProofDocumentFlow(proof, expected);
  });

  btnCopyOutput.addEventListener('click', () => copy(out.value));

  // ===== Transcript ‚Üí JSON helpers =====
  function defaultMeetingId() {
    const d = new Date();
    const yyyy = d.getFullYear();
    const mm = String(d.getMonth()+1).padStart(2, '0');
    const dd = String(d.getDate()).padStart(2, '0');
    return `Meeting-${yyyy}-${mm}-${dd}`;
  }

  function ensureMeetingDefaults() {
    if (meetingIdInput && !meetingIdInput.value) {
      meetingIdInput.value = defaultMeetingId();
    }
    if (meetingTsInput && !meetingTsInput.value) {
      meetingTsInput.value = new Date().toISOString();
    }
  }

  function firstSentence(str) {
    const s = String(str || '').replace(/\s+/g, ' ').trim();
    if (!s) return '';
    const m = s.match(/^(.{1,140}?[\.\!\?])\s/);
    return (m ? m[1] : s.slice(0, 80));
  }

  function parseTranscriptToItems(text) {
    const cleaned = String(text || '').replace(/\r\n?/g, '\n').trim();
    if (!cleaned) return [];

    const lines = cleaned.split('\n');

    // Pass 1: marker-based extraction (Agenda:/Topic:/Item:, bullets -,*,‚Ä¢, or numbered 1.)
    const items = [];
    let current = null;
    const flush = () => {
      if (current) {
        const agenda = (current.agenda || '').trim();
        const notes = current.notes.join('\n').trim();
        if (agenda || notes) items.push({ agenda: agenda || firstSentence(notes), notes });
        current = null;
      }
    };

    const agendaRe = /^\s*(?:agenda|topic|item)\s*[:\-]\s*(.+)$/i;
    const bulletRe = /^\s*(?:[\-\*\u2022]|[0-9]{1,2}\.)\s+(.+)$/;

    for (const raw of lines) {
      const line = raw.trimRight();
      if (!line.trim()) { // allow blank lines inside notes; they help the paragraph fallback
        if (current) current.notes.push('');
        continue;
      }
      let m;
      if ((m = line.match(agendaRe))) {
        flush();
        current = { agenda: m[1].trim(), notes: [] };
        continue;
      }
      if ((m = line.match(bulletRe))) {
        flush();
        current = { agenda: m[1].trim(), notes: [] };
        continue;
      }
      // speaker timestamp lines like "[00:10] Alice: ..."
      // treat as note content
      if (!current) {
        current = { agenda: firstSentence(line), notes: [line] };
      } else {
        current.notes.push(line);
      }
    }
    flush();

    if (items.length > 0) {
      return items.slice(0, 100); // guardrail: max 100 items
    }

    // Pass 2: paragraph-based fallback (split by blank lines)
    const paragraphs = cleaned.split(/\n\s*\n+/).map(p => p.trim()).filter(Boolean);
    const paraItems = paragraphs.map(p => ({ agenda: firstSentence(p), notes: p }));
    return paraItems.slice(0, 100);
  }

  function openTranscriptOverlay() {
    ensureMeetingDefaults();
    closeExampleOverlay();
    if (!transcriptOverlay?.classList.contains('open')) {
      transcriptOverlay.classList.add('open');
      document.body.classList.add('modal-open');
      transcriptOverlay.setAttribute('aria-hidden', 'false');
      log('> transcript converter opened');
    }
  }

  function closeTranscriptOverlay() {
    if (transcriptOverlay?.classList.contains('open')) {
      transcriptOverlay.classList.remove('open');
      if (!exampleOverlay?.classList.contains('open')) {
        document.body.classList.remove('modal-open');
      }
      transcriptOverlay.setAttribute('aria-hidden', 'true');
      log('> transcript converter closed');
    }
  }

  btnTranscriptPanel?.addEventListener('click', () => {
    openTranscriptOverlay();
  });

  btnTranscriptClose?.addEventListener('click', () => {
    closeTranscriptOverlay();
  });

  transcriptOverlay?.addEventListener('click', (event) => {
    if (event.target === transcriptOverlay) {
      closeTranscriptOverlay();
    }
  });

  document.addEventListener('keydown', (event) => {
    if (event.key !== 'Escape') {
      return;
    }
    if (transcriptOverlay?.classList.contains('open')) {
      closeTranscriptOverlay();
      return;
    }
    if (exampleOverlay?.classList.contains('open')) {
      closeExampleOverlay();
    }
  });

  transcriptFileInput?.addEventListener('change', async (e) => {
    const f = e.target.files && e.target.files[0];
    if (!f) return;
    const text = await f.text().catch(() => '');
    if (text) {
      transcriptInput.value = text;
      stepLog('Step 0', `Loaded transcript file ${f.name}`, 'ok');
    } else {
      stepLog('Step 0', 'Failed to read transcript file', 'bad');
    }
  });

  btnParseTranscript?.addEventListener('click', () => {
    const text = transcriptInput?.value || '';
    if (!text.trim()) {
      stepLog('Step 0', 'Paste a transcript first', 'bad');
      return;
    }
    ensureMeetingDefaults();
    const items = parseTranscriptToItems(text);
    if (!items.length) {
      stepLog('Step 0', 'Could not detect bullet markers; falling back to paragraphs', 'bad');
    }
    const meeting_id = (meetingIdInput?.value || '').trim() || defaultMeetingId();
    const timestamp = (meetingTsInput?.value || '').trim() || new Date().toISOString();
    const salt = (saltInput?.value || '').trim();
    const meeting = Object.assign({ meeting_id, timestamp, items }, salt ? { salt } : {});
    const json = JSON.stringify(meeting, null, 2);
    if (transcriptJsonOutput) {
      transcriptJsonOutput.value = json;
    }
    lastTranscriptItemsCount = items.length;
    stepLog('Step 0', `Converted transcript into ${items.length || 1} item${items.length === 1 ? '' : 's'} of meeting JSON`, 'ok');
  });

  btnTranscriptCopy?.addEventListener('click', () => {
    if (!transcriptJsonOutput?.value.trim()) {
      stepLog('Step 0', 'Convert transcript before copying', 'bad');
      return;
    }
    copy(transcriptJsonOutput.value);
    stepLog('Step 0', 'Transcript JSON copied to clipboard', 'ok');
  });

  btnTranscriptDownload?.addEventListener('click', () => {
    const payload = transcriptJsonOutput?.value.trim();
    if (!payload) {
      stepLog('Step 0', 'Convert transcript before downloading', 'bad');
      return;
    }
    const baseName = (meetingIdInput?.value || defaultMeetingId()).replace(/[^a-z0-9\-]+/gi, '_') || 'meeting';
    downloadJsonFile(`${baseName}.json`, payload);
    stepLog('Step 0', 'Downloaded meeting JSON', 'ok');
  });

  btnTranscriptFill?.addEventListener('click', async () => {
    const payload = transcriptJsonOutput?.value.trim();
    if (!payload) {
      stepLog('Step 0', 'Convert transcript before sending to Step 1', 'bad');
      return;
    }
    try {
      const parsed = JSON.parse(payload);
      lastTranscriptItemsCount = Array.isArray(parsed.items) ? parsed.items.length : 0;
    } catch (_) {
      lastTranscriptItemsCount = 0;
    }
    jsonBox.value = payload;
    updateAgendaList();
    setIntegrity(null);
    closeTranscriptOverlay();
    selectedProofIndex = 0;
    stepLog('Step 0', 'Meeting JSON filled into Step 1', 'ok');
    if (lastTranscriptItemsCount > 1) {
      await computeRootFlow();
      const proofResult = await generateProofFlow(0);
      if (proofResult) {
        const step5 = document.getElementById('step-5');
        const step6 = document.getElementById('step-6');
        if (step5) step5.open = true;
        if (step6) step6.open = true;
        stepLog('Step 6', 'Auto-generated proof for the first item from transcript', 'ok');
      }
    }
  });

  blsModeRadios.forEach((radio) => {
    radio.addEventListener('change', () => {
      if (!radio.checked) {
        return;
      }
      setBlsMode(radio.value);
      const label = radio.value === BLS_MODES.POP ? 'Aggregation mode ‚Üí PoP' : 'Aggregation mode ‚Üí Augmentation';
      stepLog('Step 3', label, 'ok');
    });
  });

  btnBlsGenerateSk?.addEventListener('click', async () => {
    const bytes = new Uint8Array(32);
    crypto.getRandomValues(bytes);
    const skHex = Array.from(bytes, (byte) => byte.toString(16).padStart(2, '0')).join('');
    if (blsSkInput) {
      blsSkInput.value = skHex;
    }
    try {
      const pkHex = await pkFromSk(skHex);
      if (blsPkInput) {
        blsPkInput.value = pkHex;
      }
      stepLog('Step 3', 'Generated demo-only secret/public key pair', 'ok');
    } catch (error) {
      stepLog('Step 3', `Key derivation failed: ${error.message || error}`, 'bad');
    }
  });

  blsSkInput?.addEventListener('input', () => {
    schedulePublicKeyDerive();
  });

  btnBlsGeneratePop?.addEventListener('click', async () => {
    if (blsState.mode !== BLS_MODES.POP) {
      stepLog('Step 3', 'Switch to PoP mode to generate a proof.', 'bad');
      return;
    }
    const skHex = normalizeHex(blsSkInput?.value);
    if (skHex.length !== 64) {
      stepLog('Step 3', 'Provide a 32-byte secret key first.', 'bad');
      return;
    }
    try {
      await ensureBlsBackendLogged();
      const popHex = await blsPopProve(skHex);
      if (blsPopInput) {
        blsPopInput.value = popHex;
      }
      const pkHex = await pkFromSk(skHex);
      if (blsPkInput) {
        blsPkInput.value = pkHex;
      }
      stepLog('Step 3', 'Generated proof-of-possession', 'ok');
    } catch (error) {
      stepLog('Step 3', `PoP generation failed: ${error.message || error}`, 'bad');
    }
  });

  btnBlsSign?.addEventListener('click', async () => {
    if (!blsState.attestation || !blsState.digest) {
      stepLog('Step 3', 'Compute the Merkle root first.', 'bad');
      return;
    }
    const skHex = normalizeHex(blsSkInput?.value);
    if (skHex.length !== 64) {
      stepLog('Step 3', 'Provide a 32-byte secret key.', 'bad');
      return;
    }
    try {
      const pkHex = await ensurePublicKey({ emitError: true });
      if (!pkHex) {
        return;
      }
      await ensureBlsBackendLogged();
      let msg;
      if (blsState.mode === BLS_MODES.AUG) {
        const pkBytes = hexToBytes(pkHex);
        msg = await computeAugmentedMessage(pkBytes, blsState.digest);
      } else {
        msg = blsState.digest;
      }
      const sigHex = await blsSign(skHex, msg);
      if (blsSignatureTextarea) {
        blsSignatureTextarea.value = sigHex;
      }
      blsState.lastSignature = {
        pk: pkHex,
        sig: sigHex,
        pop: blsState.mode === BLS_MODES.POP ? normalizeHex(blsPopInput?.value) || undefined : undefined,
      };
      const byteLength = sigHex.length / 2;
      stepLog('Step 3', `Signed attestation (${byteLength}-byte BLS)`, 'ok');
    } catch (error) {
      stepLog('Step 3', `Signing failed: ${error.message || error}`, 'bad');
    }
  });

  btnBlsAddSelf?.addEventListener('click', () => {
    if (!blsState.lastSignature) {
      stepLog('Step 3', 'Sign the attestation before adding it to the list.', 'bad');
      return;
    }
    try {
      const payload = {
        pk: blsState.lastSignature.pk,
        sig: blsState.lastSignature.sig,
        pop: blsState.mode === BLS_MODES.POP ? normalizeHex(blsPopInput?.value || blsState.lastSignature.pop || '') : undefined,
      };
      if (blsState.mode === BLS_MODES.POP && !payload.pop) {
        stepLog('Step 3', 'Generate your PoP before adding to the list.', 'bad');
        return;
      }
      addSignerEntry(payload, { silent: true });
      stepLog('Step 3', 'Added your signature to the list', 'ok');
    } catch (error) {
      stepLog('Step 3', `Could not add signature: ${error.message || error}`, 'bad');
    }
  });

  btnBlsAddRow?.addEventListener('click', () => {
    try {
      const payload = {
        pk: blsAddPkInput?.value,
        sig: blsAddSigInput?.value,
      };
      if (blsState.mode === BLS_MODES.POP) {
        payload.pop = blsAddPopInput?.value;
      }
      addSignerEntry(payload);
      if (blsAddPkInput) blsAddPkInput.value = '';
      if (blsAddSigInput) blsAddSigInput.value = '';
      if (blsAddPopInput) blsAddPopInput.value = '';
    } catch (error) {
      stepLog('Step 3', `Could not add signer: ${error.message || error}`, 'bad');
    }
  });

  btnBlsClearSigners?.addEventListener('click', () => {
    blsState.signers = [];
    renderBlsSigners();
    clearBlsAggregate(true);
    stepLog('Step 3', 'Cleared collected signatures', 'ok');
  });

  btnBlsAggregate?.addEventListener('click', async () => {
    if (!blsState.attestation || !blsState.digest) {
      stepLog('Step 3', 'Compute the Merkle root first.', 'bad');
      return;
    }
    if (!blsState.signers.length) {
      stepLog('Step 3', 'Collect signatures before aggregating.', 'bad');
      return;
    }
    try {
      await ensureBlsBackendLogged();
      const pkList = blsState.signers.map((entry) => entry.pk);
      const signatures = blsState.signers.map((entry) => entry.sig);
      if (blsState.mode === BLS_MODES.POP) {
        for (const entry of blsState.signers) {
          if (!entry.pop) {
            stepLog('Step 3', 'All signers need a PoP in proof-of-possession mode.', 'bad');
            setBlsAggregateStatus('bad', 'Missing proof-of-possession');
            setIntegrity('bad', 'PoP missing');
            return;
          }
        }
        for (const entry of blsState.signers) {
          const cacheKey = `${entry.pk}:${entry.pop}`;
          if (!blsPopCache.get(cacheKey)) {
            // eslint-disable-next-line no-await-in-loop
            const valid = await blsPopVerify(entry.pk, entry.pop);
            if (!valid) {
              stepLog('Step 3', `Invalid PoP for ${entry.pk.slice(0, 8)}‚Ä¶`, 'bad');
              setBlsAggregateStatus('bad', 'Invalid PoP');
              setIntegrity('bad', 'Invalid PoP');
              return;
            }
            blsPopCache.set(cacheKey, true);
          }
        }
        const aggregateHex = await blsAggregateSigs(signatures);
        stepLog('Step 3', `Aggregated ${signatures.length} signatures`, 'ok');
        const ok = await blsFastAggregateVerifyPop(pkList, blsState.digest, aggregateHex);
        if (blsAggregateTextarea) {
          blsAggregateTextarea.value = aggregateHex;
        }
        blsState.aggregate = { sig: aggregateHex, valid: ok, mode: blsState.mode, count: signatures.length };
        setBlsAggregateStatus(ok ? 'ok' : 'bad', ok ? 'FastAggregateVerify ‚Üí OK' : 'FastAggregateVerify ‚Üí FAIL');
        setIntegrity(ok ? 'ok' : 'bad', ok ? 'Aggregate verified' : 'Aggregate verify failed');
        stepLog('Step 3', ok ? 'FastAggregateVerify ‚Üí OK' : 'FastAggregateVerify ‚Üí FAIL', ok ? 'ok' : 'bad');
        if (!ok) {
          stepLog('Step 3', 'Aggregate verification failed', 'bad');
        }
      } else {
        const verification = await blsAggregateVerifyAug(pkList, blsState.digest, signatures);
        if (blsAggregateTextarea) {
          blsAggregateTextarea.value = verification.aggregate;
        }
        blsState.aggregate = { sig: verification.aggregate, valid: verification.ok, mode: blsState.mode, count: signatures.length };
        setBlsAggregateStatus(verification.ok ? 'ok' : 'bad', verification.ok ? 'AggregateVerify ‚Üí OK' : 'AggregateVerify ‚Üí FAIL');
        setIntegrity(verification.ok ? 'ok' : 'bad', verification.ok ? 'Aggregate verified' : 'Aggregate verify failed');
        stepLog('Step 3', `Aggregated ${signatures.length} signatures`, 'ok');
        stepLog('Step 3', verification.ok ? 'AggregateVerify ‚Üí OK' : 'AggregateVerify ‚Üí FAIL', verification.ok ? 'ok' : 'bad');
        if (!verification.ok) {
          stepLog('Step 3', 'Aggregate verification failed', 'bad');
        }
      }
    } catch (error) {
      setBlsAggregateStatus('bad', 'Aggregation error');
      setIntegrity('bad', 'Aggregation error');
      stepLog('Step 3', `Aggregation failed: ${error.message || error}`, 'bad');
    }
  });

  btnBlsCopyPayload?.addEventListener('click', () => {
    if (!blsState.attestation) {
      stepLog('Step 3', 'Compute the Merkle root first.', 'bad');
      return;
    }
    const attestationObject = blsState.canonicalJson ? JSON.parse(blsState.canonicalJson) : {};
    const signersPayload = blsState.signers.map((entry) => {
      const signer = { pk: entry.pk, sig: entry.sig };
      if (blsState.mode === BLS_MODES.POP) {
        signer.pop = entry.pop;
      }
      return signer;
    });
    const aggregatePayload = blsState.aggregate
      ? { sig: blsState.aggregate.sig, valid: Boolean(blsState.aggregate.valid) }
      : { sig: '', valid: false };
    const bundle = {
      attestation: attestationObject,
      signers: signersPayload,
      aggregate: aggregatePayload,
    };
    copy(JSON.stringify(bundle, null, 2));
    stepLog('Step 3', 'Copied attestation bundle to clipboard', 'ok');
  });

  btnBlsCopyAggregate?.addEventListener('click', () => {
    if (!blsState.aggregate?.sig) {
      stepLog('Step 3', 'Aggregate signature not available yet.', 'bad');
      return;
    }
    copy(blsState.aggregate.sig);
    stepLog('Step 3', 'Aggregate signature copied', 'ok');
  });

  updateBlsModeUI();
  renderBlsSigners();

  whyLinks.forEach((link) => {
    link.addEventListener('click', (event) => {
      event.preventDefault();
      out.value = [
        'Why salting matters:',
        '- Without a salt, a guessable phrase might be brute-checked against a hash.',
        '- Adding a random per-meeting salt makes hashes unique and unguessable.',
        '- Include the salt in each item leaf derivation, or in the meeting metadata.',
      ].join('\n');
      stepLog('Step 2', 'Opened salting note', 'ok');
    });
  });

  resetFeedChecklist();
  updateAgendaList();
  setIntegrity(null);
})();
</script>
</body>
</html>
